/* tslint:disable */
/* eslint-disable */
/**
 * Skafis užduočių bankas API
 * This is bankas.skafis.lt API. https://api.bankas.skafis.lt
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface CategoryListDto
 */
export interface CategoryListDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof CategoryListDto
     */
    'categories': Array<string>;
}
/**
 * 
 * @export
 * @interface CategoryPostDto
 */
export interface CategoryPostDto {
    /**
     * 
     * @type {string}
     * @memberof CategoryPostDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryPostDto
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface CountDto
 */
export interface CountDto {
    /**
     * 
     * @type {number}
     * @memberof CountDto
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface IdDto
 */
export interface IdDto {
    /**
     * 
     * @type {string}
     * @memberof IdDto
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ImageSrcDto
 */
export interface ImageSrcDto {
    /**
     * 
     * @type {string}
     * @memberof ImageSrcDto
     */
    'src': string;
}
/**
 * 
 * @export
 * @interface Problem
 */
export interface Problem {
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof Problem
     */
    'sourceListNr': number;
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'skfCode': string;
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'problemText': string;
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'problemImagePath': string;
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'answerText': string;
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'answerImagePath': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Problem
     */
    'categories': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'sourceId': string;
    /**
     * 
     * @type {boolean}
     * @memberof Problem
     */
    'isApproved': boolean;
}
/**
 * 
 * @export
 * @interface ProblemDisplayViewDto
 */
export interface ProblemDisplayViewDto {
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof ProblemDisplayViewDto
     */
    'sourceListNr': number;
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'skfCode': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'problemText': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'problemImageSrc': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'answerText': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'answerImageSrc': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProblemDisplayViewDto
     */
    'categories': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'sourceId': string;
}
/**
 * 
 * @export
 * @interface ProblemPostDto
 */
export interface ProblemPostDto {
    /**
     * 
     * @type {string}
     * @memberof ProblemPostDto
     */
    'skfCode': string;
    /**
     * 
     * @type {number}
     * @memberof ProblemPostDto
     */
    'sourceListNr': number;
    /**
     * 
     * @type {string}
     * @memberof ProblemPostDto
     */
    'problemImagePath': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemPostDto
     */
    'answerImagePath': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemPostDto
     */
    'problemText': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemPostDto
     */
    'answerText': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProblemPostDto
     */
    'categories': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ProblemPostDto
     */
    'sourceId': string;
}
/**
 * 
 * @export
 * @interface ProblemSubmitDto
 */
export interface ProblemSubmitDto {
    /**
     * 
     * @type {number}
     * @memberof ProblemSubmitDto
     */
    'sourceListNr': number;
    /**
     * 
     * @type {string}
     * @memberof ProblemSubmitDto
     */
    'problemText': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemSubmitDto
     */
    'answerText': string;
}
/**
 * 
 * @export
 * @interface ProblemTextsDto
 */
export interface ProblemTextsDto {
    /**
     * 
     * @type {number}
     * @memberof ProblemTextsDto
     */
    'sourceListNr': number;
    /**
     * 
     * @type {string}
     * @memberof ProblemTextsDto
     */
    'problemText': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemTextsDto
     */
    'answerText': string;
}
/**
 * 
 * @export
 * @interface ReviewMsgDto
 */
export interface ReviewMsgDto {
    /**
     * 
     * @type {string}
     * @memberof ReviewMsgDto
     */
    'reviewMessage': string;
}
/**
 * 
 * @export
 * @interface Source
 */
export interface Source {
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'reviewStatus': SourceReviewStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'reviewHistory': string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'authorId': string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'createdOn': string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'lastModifiedOn': string;
}

export const SourceReviewStatusEnum = {
    Pending: 'PENDING',
    Rejected: 'REJECTED',
    Approved: 'APPROVED'
} as const;

export type SourceReviewStatusEnum = typeof SourceReviewStatusEnum[keyof typeof SourceReviewStatusEnum];

/**
 * 
 * @export
 * @interface SourceDisplayDto
 */
export interface SourceDisplayDto {
    /**
     * 
     * @type {string}
     * @memberof SourceDisplayDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SourceDisplayDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SourceDisplayDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof SourceDisplayDto
     */
    'reviewStatus': SourceDisplayDtoReviewStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof SourceDisplayDto
     */
    'reviewHistory': string;
    /**
     * 
     * @type {string}
     * @memberof SourceDisplayDto
     */
    'authorUsername': string;
    /**
     * 
     * @type {string}
     * @memberof SourceDisplayDto
     */
    'createdOn': string;
    /**
     * 
     * @type {string}
     * @memberof SourceDisplayDto
     */
    'lastModifiedOn': string;
}

export const SourceDisplayDtoReviewStatusEnum = {
    Pending: 'PENDING',
    Rejected: 'REJECTED',
    Approved: 'APPROVED'
} as const;

export type SourceDisplayDtoReviewStatusEnum = typeof SourceDisplayDtoReviewStatusEnum[keyof typeof SourceDisplayDtoReviewStatusEnum];

/**
 * 
 * @export
 * @interface SourcePostDto
 */
export interface SourcePostDto {
    /**
     * 
     * @type {string}
     * @memberof SourcePostDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SourcePostDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof SourcePostDto
     */
    'reviewStatus': SourcePostDtoReviewStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof SourcePostDto
     */
    'reviewHistory': string;
    /**
     * 
     * @type {string}
     * @memberof SourcePostDto
     */
    'authorId': string;
    /**
     * 
     * @type {string}
     * @memberof SourcePostDto
     */
    'createdOn': string;
    /**
     * 
     * @type {string}
     * @memberof SourcePostDto
     */
    'lastModifiedOn': string;
}

export const SourcePostDtoReviewStatusEnum = {
    Pending: 'PENDING',
    Rejected: 'REJECTED',
    Approved: 'APPROVED'
} as const;

export type SourcePostDtoReviewStatusEnum = typeof SourcePostDtoReviewStatusEnum[keyof typeof SourcePostDtoReviewStatusEnum];

/**
 * 
 * @export
 * @interface SourceSubmitDto
 */
export interface SourceSubmitDto {
    /**
     * 
     * @type {string}
     * @memberof SourceSubmitDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SourceSubmitDto
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface UserBioDto
 */
export interface UserBioDto {
    /**
     * 
     * @type {string}
     * @memberof UserBioDto
     */
    'bio': string;
}

/**
 * ApprovalControllerApi - axios parameter creator
 * @export
 */
export const ApprovalControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Approve source with problems by source ID.
         * @summary ADMIN. Approve source with problems
         * @param {string} sourceId 
         * @param {ReviewMsgDto} reviewMsgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approve: async (sourceId: string, reviewMsgDto: ReviewMsgDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('approve', 'sourceId', sourceId)
            // verify required parameter 'reviewMsgDto' is not null or undefined
            assertParamExists('approve', 'reviewMsgDto', reviewMsgDto)
            const localVarPath = `/approval/approve/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reviewMsgDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete answer image by ID.
         * @summary USER but owning. Delete answer image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnswerImage: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAnswerImage', 'id', id)
            const localVarPath = `/approval/problem/answerImage/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete problem by ID.
         * @summary USER but owning. Delete problem
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProblem1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProblem1', 'id', id)
            const localVarPath = `/approval/problem/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete problem image by ID.
         * @summary USER but owning. Delete problem image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProblemImage: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProblemImage', 'id', id)
            const localVarPath = `/approval/problem/problemImage/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete source with all problems by ID.
         * @summary USER but owning. Delete source with all problems
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSource1', 'id', id)
            const localVarPath = `/approval/source/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all sources submitted by the current user.
         * @summary USER. Get my sources
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMySources: async (page?: number, size?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/approval/mySources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all sources submitted for approval (or already approved).
         * @summary ADMIN. Get all sources
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingSources: async (page?: number, size?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/approval/sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all problems submitted for the source.
         * @summary Either USER with it\'s problems, or ADMIN, or PUBLIC && source.reviewStatus === ReviewStatus.APPROVED.
         * @param {string} sourceId 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProblemsBySource: async (sourceId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getProblemsBySource', 'sourceId', sourceId)
            const localVarPath = `/approval/problemsBySource/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reject source with problems by source ID.
         * @summary ADMIN. Reject source with problems
         * @param {string} sourceId 
         * @param {ReviewMsgDto} reviewMsgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reject: async (sourceId: string, reviewMsgDto: ReviewMsgDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('reject', 'sourceId', sourceId)
            // verify required parameter 'reviewMsgDto' is not null or undefined
            assertParamExists('reject', 'reviewMsgDto', reviewMsgDto)
            const localVarPath = `/approval/reject/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reviewMsgDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 415 from swagger.... Submit problem with images for approval. returns ID of the created problem.
         * @summary USER. Submit problem data with images
         * @param {string} sourceId 
         * @param {ProblemSubmitDto} problem 
         * @param {File} [problemImageFile] 
         * @param {File} [answerImageFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitProblem: async (sourceId: string, problem: ProblemSubmitDto, problemImageFile?: File, answerImageFile?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('submitProblem', 'sourceId', sourceId)
            // verify required parameter 'problem' is not null or undefined
            assertParamExists('submitProblem', 'problem', problem)
            const localVarPath = `/approval/submit/problem/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (problem !== undefined) { 
                localVarFormParams.append('problem', new Blob([JSON.stringify(problem)], { type: "application/json", }));
            }
    
            if (problemImageFile !== undefined) { 
                localVarFormParams.append('problemImageFile', problemImageFile as any);
            }
    
            if (answerImageFile !== undefined) { 
                localVarFormParams.append('answerImageFile', answerImageFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit source data for approval. Returns the ID of the created source.
         * @summary USER. Submit source data
         * @param {SourceSubmitDto} sourceSubmitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSourceData: async (sourceSubmitDto: SourceSubmitDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceSubmitDto' is not null or undefined
            assertParamExists('submitSourceData', 'sourceSubmitDto', sourceSubmitDto)
            const localVarPath = `/approval/submit/source`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceSubmitDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update source data by ID.
         * @summary USER but owning. Update source data
         * @param {string} id 
         * @param {SourceSubmitDto} sourceSubmitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, sourceSubmitDto: SourceSubmitDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            // verify required parameter 'sourceSubmitDto' is not null or undefined
            assertParamExists('update', 'sourceSubmitDto', sourceSubmitDto)
            const localVarPath = `/approval/source/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceSubmitDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update problem texts by ID.
         * @summary USER but owning. Update problem texts
         * @param {string} id 
         * @param {ProblemTextsDto} problemTextsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProblemTexts: async (id: string, problemTextsDto: ProblemTextsDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProblemTexts', 'id', id)
            // verify required parameter 'problemTextsDto' is not null or undefined
            assertParamExists('updateProblemTexts', 'problemTextsDto', problemTextsDto)
            const localVarPath = `/approval/problem/texts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(problemTextsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload answer image by ID.
         * @summary USER but owning. Upload answer image
         * @param {string} id 
         * @param {File} answerImageFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAnswerImage: async (id: string, answerImageFile: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadAnswerImage', 'id', id)
            // verify required parameter 'answerImageFile' is not null or undefined
            assertParamExists('uploadAnswerImage', 'answerImageFile', answerImageFile)
            const localVarPath = `/approval/problem/answerImage/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (answerImageFile !== undefined) { 
                localVarFormParams.append('answerImageFile', answerImageFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload problem image by ID.
         * @summary USER but owning. Upload problem image
         * @param {string} id 
         * @param {File} problemImageFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProblemImage: async (id: string, problemImageFile: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadProblemImage', 'id', id)
            // verify required parameter 'problemImageFile' is not null or undefined
            assertParamExists('uploadProblemImage', 'problemImageFile', problemImageFile)
            const localVarPath = `/approval/problem/problemImage/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (problemImageFile !== undefined) { 
                localVarFormParams.append('problemImageFile', problemImageFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApprovalControllerApi - functional programming interface
 * @export
 */
export const ApprovalControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApprovalControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Approve source with problems by source ID.
         * @summary ADMIN. Approve source with problems
         * @param {string} sourceId 
         * @param {ReviewMsgDto} reviewMsgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approve(sourceId: string, reviewMsgDto: ReviewMsgDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceDisplayDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approve(sourceId, reviewMsgDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApprovalControllerApi.approve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete answer image by ID.
         * @summary USER but owning. Delete answer image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAnswerImage(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAnswerImage(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApprovalControllerApi.deleteAnswerImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete problem by ID.
         * @summary USER but owning. Delete problem
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProblem1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProblem1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApprovalControllerApi.deleteProblem1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete problem image by ID.
         * @summary USER but owning. Delete problem image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProblemImage(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProblemImage(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApprovalControllerApi.deleteProblemImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete source with all problems by ID.
         * @summary USER but owning. Delete source with all problems
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSource1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSource1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApprovalControllerApi.deleteSource1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all sources submitted by the current user.
         * @summary USER. Get my sources
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMySources(page?: number, size?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SourceDisplayDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMySources(page, size, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApprovalControllerApi.getMySources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all sources submitted for approval (or already approved).
         * @summary ADMIN. Get all sources
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPendingSources(page?: number, size?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SourceDisplayDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPendingSources(page, size, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApprovalControllerApi.getPendingSources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all problems submitted for the source.
         * @summary Either USER with it\'s problems, or ADMIN, or PUBLIC && source.reviewStatus === ReviewStatus.APPROVED.
         * @param {string} sourceId 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProblemsBySource(sourceId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProblemDisplayViewDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProblemsBySource(sourceId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApprovalControllerApi.getProblemsBySource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reject source with problems by source ID.
         * @summary ADMIN. Reject source with problems
         * @param {string} sourceId 
         * @param {ReviewMsgDto} reviewMsgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reject(sourceId: string, reviewMsgDto: ReviewMsgDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceDisplayDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reject(sourceId, reviewMsgDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApprovalControllerApi.reject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 415 from swagger.... Submit problem with images for approval. returns ID of the created problem.
         * @summary USER. Submit problem data with images
         * @param {string} sourceId 
         * @param {ProblemSubmitDto} problem 
         * @param {File} [problemImageFile] 
         * @param {File} [answerImageFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitProblem(sourceId: string, problem: ProblemSubmitDto, problemImageFile?: File, answerImageFile?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitProblem(sourceId, problem, problemImageFile, answerImageFile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApprovalControllerApi.submitProblem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submit source data for approval. Returns the ID of the created source.
         * @summary USER. Submit source data
         * @param {SourceSubmitDto} sourceSubmitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitSourceData(sourceSubmitDto: SourceSubmitDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitSourceData(sourceSubmitDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApprovalControllerApi.submitSourceData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update source data by ID.
         * @summary USER but owning. Update source data
         * @param {string} id 
         * @param {SourceSubmitDto} sourceSubmitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, sourceSubmitDto: SourceSubmitDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceDisplayDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, sourceSubmitDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApprovalControllerApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update problem texts by ID.
         * @summary USER but owning. Update problem texts
         * @param {string} id 
         * @param {ProblemTextsDto} problemTextsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProblemTexts(id: string, problemTextsDto: ProblemTextsDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProblemTexts(id, problemTextsDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApprovalControllerApi.updateProblemTexts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload answer image by ID.
         * @summary USER but owning. Upload answer image
         * @param {string} id 
         * @param {File} answerImageFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadAnswerImage(id: string, answerImageFile: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageSrcDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadAnswerImage(id, answerImageFile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApprovalControllerApi.uploadAnswerImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload problem image by ID.
         * @summary USER but owning. Upload problem image
         * @param {string} id 
         * @param {File} problemImageFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadProblemImage(id: string, problemImageFile: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageSrcDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadProblemImage(id, problemImageFile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApprovalControllerApi.uploadProblemImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApprovalControllerApi - factory interface
 * @export
 */
export const ApprovalControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApprovalControllerApiFp(configuration)
    return {
        /**
         * Approve source with problems by source ID.
         * @summary ADMIN. Approve source with problems
         * @param {string} sourceId 
         * @param {ReviewMsgDto} reviewMsgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approve(sourceId: string, reviewMsgDto: ReviewMsgDto, options?: any): AxiosPromise<SourceDisplayDto> {
            return localVarFp.approve(sourceId, reviewMsgDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete answer image by ID.
         * @summary USER but owning. Delete answer image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnswerImage(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAnswerImage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete problem by ID.
         * @summary USER but owning. Delete problem
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProblem1(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProblem1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete problem image by ID.
         * @summary USER but owning. Delete problem image
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProblemImage(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProblemImage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete source with all problems by ID.
         * @summary USER but owning. Delete source with all problems
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource1(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSource1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all sources submitted by the current user.
         * @summary USER. Get my sources
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMySources(page?: number, size?: number, search?: string, options?: any): AxiosPromise<Array<SourceDisplayDto>> {
            return localVarFp.getMySources(page, size, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all sources submitted for approval (or already approved).
         * @summary ADMIN. Get all sources
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingSources(page?: number, size?: number, search?: string, options?: any): AxiosPromise<Array<SourceDisplayDto>> {
            return localVarFp.getPendingSources(page, size, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all problems submitted for the source.
         * @summary Either USER with it\'s problems, or ADMIN, or PUBLIC && source.reviewStatus === ReviewStatus.APPROVED.
         * @param {string} sourceId 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProblemsBySource(sourceId: string, page?: number, size?: number, options?: any): AxiosPromise<Array<ProblemDisplayViewDto>> {
            return localVarFp.getProblemsBySource(sourceId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Reject source with problems by source ID.
         * @summary ADMIN. Reject source with problems
         * @param {string} sourceId 
         * @param {ReviewMsgDto} reviewMsgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reject(sourceId: string, reviewMsgDto: ReviewMsgDto, options?: any): AxiosPromise<SourceDisplayDto> {
            return localVarFp.reject(sourceId, reviewMsgDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 415 from swagger.... Submit problem with images for approval. returns ID of the created problem.
         * @summary USER. Submit problem data with images
         * @param {string} sourceId 
         * @param {ProblemSubmitDto} problem 
         * @param {File} [problemImageFile] 
         * @param {File} [answerImageFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitProblem(sourceId: string, problem: ProblemSubmitDto, problemImageFile?: File, answerImageFile?: File, options?: any): AxiosPromise<IdDto> {
            return localVarFp.submitProblem(sourceId, problem, problemImageFile, answerImageFile, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit source data for approval. Returns the ID of the created source.
         * @summary USER. Submit source data
         * @param {SourceSubmitDto} sourceSubmitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSourceData(sourceSubmitDto: SourceSubmitDto, options?: any): AxiosPromise<IdDto> {
            return localVarFp.submitSourceData(sourceSubmitDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Update source data by ID.
         * @summary USER but owning. Update source data
         * @param {string} id 
         * @param {SourceSubmitDto} sourceSubmitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, sourceSubmitDto: SourceSubmitDto, options?: any): AxiosPromise<SourceDisplayDto> {
            return localVarFp.update(id, sourceSubmitDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Update problem texts by ID.
         * @summary USER but owning. Update problem texts
         * @param {string} id 
         * @param {ProblemTextsDto} problemTextsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProblemTexts(id: string, problemTextsDto: ProblemTextsDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateProblemTexts(id, problemTextsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload answer image by ID.
         * @summary USER but owning. Upload answer image
         * @param {string} id 
         * @param {File} answerImageFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAnswerImage(id: string, answerImageFile: File, options?: any): AxiosPromise<ImageSrcDto> {
            return localVarFp.uploadAnswerImage(id, answerImageFile, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload problem image by ID.
         * @summary USER but owning. Upload problem image
         * @param {string} id 
         * @param {File} problemImageFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProblemImage(id: string, problemImageFile: File, options?: any): AxiosPromise<ImageSrcDto> {
            return localVarFp.uploadProblemImage(id, problemImageFile, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApprovalControllerApi - object-oriented interface
 * @export
 * @class ApprovalControllerApi
 * @extends {BaseAPI}
 */
export class ApprovalControllerApi extends BaseAPI {
    /**
     * Approve source with problems by source ID.
     * @summary ADMIN. Approve source with problems
     * @param {string} sourceId 
     * @param {ReviewMsgDto} reviewMsgDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalControllerApi
     */
    public approve(sourceId: string, reviewMsgDto: ReviewMsgDto, options?: RawAxiosRequestConfig) {
        return ApprovalControllerApiFp(this.configuration).approve(sourceId, reviewMsgDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete answer image by ID.
     * @summary USER but owning. Delete answer image
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalControllerApi
     */
    public deleteAnswerImage(id: string, options?: RawAxiosRequestConfig) {
        return ApprovalControllerApiFp(this.configuration).deleteAnswerImage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete problem by ID.
     * @summary USER but owning. Delete problem
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalControllerApi
     */
    public deleteProblem1(id: string, options?: RawAxiosRequestConfig) {
        return ApprovalControllerApiFp(this.configuration).deleteProblem1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete problem image by ID.
     * @summary USER but owning. Delete problem image
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalControllerApi
     */
    public deleteProblemImage(id: string, options?: RawAxiosRequestConfig) {
        return ApprovalControllerApiFp(this.configuration).deleteProblemImage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete source with all problems by ID.
     * @summary USER but owning. Delete source with all problems
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalControllerApi
     */
    public deleteSource1(id: string, options?: RawAxiosRequestConfig) {
        return ApprovalControllerApiFp(this.configuration).deleteSource1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all sources submitted by the current user.
     * @summary USER. Get my sources
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalControllerApi
     */
    public getMySources(page?: number, size?: number, search?: string, options?: RawAxiosRequestConfig) {
        return ApprovalControllerApiFp(this.configuration).getMySources(page, size, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all sources submitted for approval (or already approved).
     * @summary ADMIN. Get all sources
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalControllerApi
     */
    public getPendingSources(page?: number, size?: number, search?: string, options?: RawAxiosRequestConfig) {
        return ApprovalControllerApiFp(this.configuration).getPendingSources(page, size, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all problems submitted for the source.
     * @summary Either USER with it\'s problems, or ADMIN, or PUBLIC && source.reviewStatus === ReviewStatus.APPROVED.
     * @param {string} sourceId 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalControllerApi
     */
    public getProblemsBySource(sourceId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return ApprovalControllerApiFp(this.configuration).getProblemsBySource(sourceId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reject source with problems by source ID.
     * @summary ADMIN. Reject source with problems
     * @param {string} sourceId 
     * @param {ReviewMsgDto} reviewMsgDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalControllerApi
     */
    public reject(sourceId: string, reviewMsgDto: ReviewMsgDto, options?: RawAxiosRequestConfig) {
        return ApprovalControllerApiFp(this.configuration).reject(sourceId, reviewMsgDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 415 from swagger.... Submit problem with images for approval. returns ID of the created problem.
     * @summary USER. Submit problem data with images
     * @param {string} sourceId 
     * @param {ProblemSubmitDto} problem 
     * @param {File} [problemImageFile] 
     * @param {File} [answerImageFile] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalControllerApi
     */
    public submitProblem(sourceId: string, problem: ProblemSubmitDto, problemImageFile?: File, answerImageFile?: File, options?: RawAxiosRequestConfig) {
        return ApprovalControllerApiFp(this.configuration).submitProblem(sourceId, problem, problemImageFile, answerImageFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit source data for approval. Returns the ID of the created source.
     * @summary USER. Submit source data
     * @param {SourceSubmitDto} sourceSubmitDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalControllerApi
     */
    public submitSourceData(sourceSubmitDto: SourceSubmitDto, options?: RawAxiosRequestConfig) {
        return ApprovalControllerApiFp(this.configuration).submitSourceData(sourceSubmitDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update source data by ID.
     * @summary USER but owning. Update source data
     * @param {string} id 
     * @param {SourceSubmitDto} sourceSubmitDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalControllerApi
     */
    public update(id: string, sourceSubmitDto: SourceSubmitDto, options?: RawAxiosRequestConfig) {
        return ApprovalControllerApiFp(this.configuration).update(id, sourceSubmitDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update problem texts by ID.
     * @summary USER but owning. Update problem texts
     * @param {string} id 
     * @param {ProblemTextsDto} problemTextsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalControllerApi
     */
    public updateProblemTexts(id: string, problemTextsDto: ProblemTextsDto, options?: RawAxiosRequestConfig) {
        return ApprovalControllerApiFp(this.configuration).updateProblemTexts(id, problemTextsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload answer image by ID.
     * @summary USER but owning. Upload answer image
     * @param {string} id 
     * @param {File} answerImageFile 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalControllerApi
     */
    public uploadAnswerImage(id: string, answerImageFile: File, options?: RawAxiosRequestConfig) {
        return ApprovalControllerApiFp(this.configuration).uploadAnswerImage(id, answerImageFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload problem image by ID.
     * @summary USER but owning. Upload problem image
     * @param {string} id 
     * @param {File} problemImageFile 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalControllerApi
     */
    public uploadProblemImage(id: string, problemImageFile: File, options?: RawAxiosRequestConfig) {
        return ApprovalControllerApiFp(this.configuration).uploadProblemImage(id, problemImageFile, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CategoryControllerApi - axios parameter creator
 * @export
 */
export const CategoryControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory: async (categoryPostDto: CategoryPostDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryPostDto' is not null or undefined
            assertParamExists('createCategory', 'categoryPostDto', categoryPostDto)
            const localVarPath = `/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoryPostDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCategory', 'id', id)
            const localVarPath = `/category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCategories: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryById1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCategoryById1', 'id', id)
            const localVarPath = `/category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory: async (id: string, categoryPostDto: CategoryPostDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCategory', 'id', id)
            // verify required parameter 'categoryPostDto' is not null or undefined
            assertParamExists('updateCategory', 'categoryPostDto', categoryPostDto)
            const localVarPath = `/category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoryPostDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoryControllerApi - functional programming interface
 * @export
 */
export const CategoryControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoryControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCategory(categoryPostDto: CategoryPostDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCategory(categoryPostDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerApi.createCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCategory(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCategory(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerApi.deleteCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCategories(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Category>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCategories(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerApi.getAllCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategoryById1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategoryById1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerApi.getCategoryById1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCategory(id: string, categoryPostDto: CategoryPostDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCategory(id, categoryPostDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerApi.updateCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CategoryControllerApi - factory interface
 * @export
 */
export const CategoryControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoryControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory(categoryPostDto: CategoryPostDto, options?: any): AxiosPromise<Category> {
            return localVarFp.createCategory(categoryPostDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCategory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCategories(options?: any): AxiosPromise<Array<Category>> {
            return localVarFp.getAllCategories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryById1(id: string, options?: any): AxiosPromise<Category> {
            return localVarFp.getCategoryById1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory(id: string, categoryPostDto: CategoryPostDto, options?: any): AxiosPromise<Category> {
            return localVarFp.updateCategory(id, categoryPostDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoryControllerApi - object-oriented interface
 * @export
 * @class CategoryControllerApi
 * @extends {BaseAPI}
 */
export class CategoryControllerApi extends BaseAPI {
    /**
     * 
     * @param {CategoryPostDto} categoryPostDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public createCategory(categoryPostDto: CategoryPostDto, options?: RawAxiosRequestConfig) {
        return CategoryControllerApiFp(this.configuration).createCategory(categoryPostDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public deleteCategory(id: string, options?: RawAxiosRequestConfig) {
        return CategoryControllerApiFp(this.configuration).deleteCategory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public getAllCategories(options?: RawAxiosRequestConfig) {
        return CategoryControllerApiFp(this.configuration).getAllCategories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public getCategoryById1(id: string, options?: RawAxiosRequestConfig) {
        return CategoryControllerApiFp(this.configuration).getCategoryById1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {CategoryPostDto} categoryPostDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public updateCategory(id: string, categoryPostDto: CategoryPostDto, options?: RawAxiosRequestConfig) {
        return CategoryControllerApiFp(this.configuration).updateCategory(id, categoryPostDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProblemControllerApi - axios parameter creator
 * @export
 */
export const ProblemControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ProblemPostDto} problemPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProblem: async (problemPostDto: ProblemPostDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'problemPostDto' is not null or undefined
            assertParamExists('createProblem', 'problemPostDto', problemPostDto)
            const localVarPath = `/problem`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(problemPostDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProblem: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProblem', 'id', id)
            const localVarPath = `/problem/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProblems: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/problem`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProblemById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProblemById', 'id', id)
            const localVarPath = `/problem/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initMeta: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/problem/meta/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ProblemPostDto} problemPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProblem: async (id: string, problemPostDto: ProblemPostDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProblem', 'id', id)
            // verify required parameter 'problemPostDto' is not null or undefined
            assertParamExists('updateProblem', 'problemPostDto', problemPostDto)
            const localVarPath = `/problem/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(problemPostDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProblemControllerApi - functional programming interface
 * @export
 */
export const ProblemControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProblemControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ProblemPostDto} problemPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProblem(problemPostDto: ProblemPostDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Problem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProblem(problemPostDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProblemControllerApi.createProblem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProblem(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProblem(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProblemControllerApi.deleteProblem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllProblems(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Problem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllProblems(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProblemControllerApi.getAllProblems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProblemById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Problem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProblemById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProblemControllerApi.getProblemById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initMeta(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initMeta(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProblemControllerApi.initMeta']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {ProblemPostDto} problemPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProblem(id: string, problemPostDto: ProblemPostDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Problem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProblem(id, problemPostDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProblemControllerApi.updateProblem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProblemControllerApi - factory interface
 * @export
 */
export const ProblemControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProblemControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {ProblemPostDto} problemPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProblem(problemPostDto: ProblemPostDto, options?: any): AxiosPromise<Problem> {
            return localVarFp.createProblem(problemPostDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProblem(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProblem(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProblems(options?: any): AxiosPromise<Array<Problem>> {
            return localVarFp.getAllProblems(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProblemById(id: string, options?: any): AxiosPromise<Problem> {
            return localVarFp.getProblemById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initMeta(options?: any): AxiosPromise<void> {
            return localVarFp.initMeta(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {ProblemPostDto} problemPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProblem(id: string, problemPostDto: ProblemPostDto, options?: any): AxiosPromise<Problem> {
            return localVarFp.updateProblem(id, problemPostDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProblemControllerApi - object-oriented interface
 * @export
 * @class ProblemControllerApi
 * @extends {BaseAPI}
 */
export class ProblemControllerApi extends BaseAPI {
    /**
     * 
     * @param {ProblemPostDto} problemPostDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProblemControllerApi
     */
    public createProblem(problemPostDto: ProblemPostDto, options?: RawAxiosRequestConfig) {
        return ProblemControllerApiFp(this.configuration).createProblem(problemPostDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProblemControllerApi
     */
    public deleteProblem(id: string, options?: RawAxiosRequestConfig) {
        return ProblemControllerApiFp(this.configuration).deleteProblem(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProblemControllerApi
     */
    public getAllProblems(options?: RawAxiosRequestConfig) {
        return ProblemControllerApiFp(this.configuration).getAllProblems(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProblemControllerApi
     */
    public getProblemById(id: string, options?: RawAxiosRequestConfig) {
        return ProblemControllerApiFp(this.configuration).getProblemById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProblemControllerApi
     */
    public initMeta(options?: RawAxiosRequestConfig) {
        return ProblemControllerApiFp(this.configuration).initMeta(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {ProblemPostDto} problemPostDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProblemControllerApi
     */
    public updateProblem(id: string, problemPostDto: ProblemPostDto, options?: RawAxiosRequestConfig) {
        return ProblemControllerApiFp(this.configuration).updateProblem(id, problemPostDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PublicControllerApi - axios parameter creator
 * @export
 */
export const PublicControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApprovedSources: async (page?: number, size?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/approvedSources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories: async (page?: number, size?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoriesCount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/categories/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryById: async (categoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getCategoryById', 'categoryId', categoryId)
            const localVarPath = `/public/category/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryProblemCount: async (categoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getCategoryProblemCount', 'categoryId', categoryId)
            const localVarPath = `/public/categoryProblemCount/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} skfCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProblemBySkfCode: async (skfCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'skfCode' is not null or undefined
            assertParamExists('getProblemBySkfCode', 'skfCode', skfCode)
            const localVarPath = `/public/problem/{skfCode}`
                .replace(`{${"skfCode"}}`, encodeURIComponent(String(skfCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProblemsByCategory: async (categoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getProblemsByCategory', 'categoryId', categoryId)
            const localVarPath = `/public/problemsByCategory/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProblemsCount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/problems/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProblemsUnsorted: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/problemsUnsorted`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get source by ID. Returns source entity.
         * @summary PUBLIC if approved, USER if owned, ADMIN else
         * @param {string} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourceById1: async (sourceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getSourceById1', 'sourceId', sourceId)
            const localVarPath = `/public/source/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} authorUsername 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourcesByAuthor: async (authorUsername: string, page?: number, size?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorUsername' is not null or undefined
            assertParamExists('getSourcesByAuthor', 'authorUsername', authorUsername)
            const localVarPath = `/public/sourcesByAuthor/{authorUsername}`
                .replace(`{${"authorUsername"}}`, encodeURIComponent(String(authorUsername)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnsortedProblemsCount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/unsortedProblemsCount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicControllerApi - functional programming interface
 * @export
 */
export const PublicControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApprovedSources(page?: number, size?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SourceDisplayDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApprovedSources(page, size, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicControllerApi.getApprovedSources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategories(page?: number, size?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Category>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategories(page, size, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicControllerApi.getCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategoriesCount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategoriesCount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicControllerApi.getCategoriesCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategoryById(categoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategoryById(categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicControllerApi.getCategoryById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategoryProblemCount(categoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategoryProblemCount(categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicControllerApi.getCategoryProblemCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} skfCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProblemBySkfCode(skfCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProblemDisplayViewDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProblemBySkfCode(skfCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicControllerApi.getProblemBySkfCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProblemsByCategory(categoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProblemDisplayViewDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProblemsByCategory(categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicControllerApi.getProblemsByCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProblemsCount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProblemsCount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicControllerApi.getProblemsCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProblemsUnsorted(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProblemDisplayViewDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProblemsUnsorted(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicControllerApi.getProblemsUnsorted']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get source by ID. Returns source entity.
         * @summary PUBLIC if approved, USER if owned, ADMIN else
         * @param {string} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSourceById1(sourceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SourceDisplayDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSourceById1(sourceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicControllerApi.getSourceById1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} authorUsername 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSourcesByAuthor(authorUsername: string, page?: number, size?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SourceDisplayDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSourcesByAuthor(authorUsername, page, size, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicControllerApi.getSourcesByAuthor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnsortedProblemsCount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnsortedProblemsCount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicControllerApi.getUnsortedProblemsCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PublicControllerApi - factory interface
 * @export
 */
export const PublicControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApprovedSources(page?: number, size?: number, search?: string, options?: any): AxiosPromise<Array<SourceDisplayDto>> {
            return localVarFp.getApprovedSources(page, size, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories(page?: number, size?: number, search?: string, options?: any): AxiosPromise<Array<Category>> {
            return localVarFp.getCategories(page, size, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoriesCount(options?: any): AxiosPromise<CountDto> {
            return localVarFp.getCategoriesCount(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryById(categoryId: string, options?: any): AxiosPromise<Category> {
            return localVarFp.getCategoryById(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryProblemCount(categoryId: string, options?: any): AxiosPromise<CountDto> {
            return localVarFp.getCategoryProblemCount(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} skfCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProblemBySkfCode(skfCode: string, options?: any): AxiosPromise<ProblemDisplayViewDto> {
            return localVarFp.getProblemBySkfCode(skfCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProblemsByCategory(categoryId: string, options?: any): AxiosPromise<Array<ProblemDisplayViewDto>> {
            return localVarFp.getProblemsByCategory(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProblemsCount(options?: any): AxiosPromise<CountDto> {
            return localVarFp.getProblemsCount(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProblemsUnsorted(options?: any): AxiosPromise<Array<ProblemDisplayViewDto>> {
            return localVarFp.getProblemsUnsorted(options).then((request) => request(axios, basePath));
        },
        /**
         * Get source by ID. Returns source entity.
         * @summary PUBLIC if approved, USER if owned, ADMIN else
         * @param {string} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourceById1(sourceId: string, options?: any): AxiosPromise<SourceDisplayDto> {
            return localVarFp.getSourceById1(sourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} authorUsername 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourcesByAuthor(authorUsername: string, page?: number, size?: number, search?: string, options?: any): AxiosPromise<Array<SourceDisplayDto>> {
            return localVarFp.getSourcesByAuthor(authorUsername, page, size, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnsortedProblemsCount(options?: any): AxiosPromise<CountDto> {
            return localVarFp.getUnsortedProblemsCount(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PublicControllerApi - object-oriented interface
 * @export
 * @class PublicControllerApi
 * @extends {BaseAPI}
 */
export class PublicControllerApi extends BaseAPI {
    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicControllerApi
     */
    public getApprovedSources(page?: number, size?: number, search?: string, options?: RawAxiosRequestConfig) {
        return PublicControllerApiFp(this.configuration).getApprovedSources(page, size, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicControllerApi
     */
    public getCategories(page?: number, size?: number, search?: string, options?: RawAxiosRequestConfig) {
        return PublicControllerApiFp(this.configuration).getCategories(page, size, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicControllerApi
     */
    public getCategoriesCount(options?: RawAxiosRequestConfig) {
        return PublicControllerApiFp(this.configuration).getCategoriesCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} categoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicControllerApi
     */
    public getCategoryById(categoryId: string, options?: RawAxiosRequestConfig) {
        return PublicControllerApiFp(this.configuration).getCategoryById(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} categoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicControllerApi
     */
    public getCategoryProblemCount(categoryId: string, options?: RawAxiosRequestConfig) {
        return PublicControllerApiFp(this.configuration).getCategoryProblemCount(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} skfCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicControllerApi
     */
    public getProblemBySkfCode(skfCode: string, options?: RawAxiosRequestConfig) {
        return PublicControllerApiFp(this.configuration).getProblemBySkfCode(skfCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} categoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicControllerApi
     */
    public getProblemsByCategory(categoryId: string, options?: RawAxiosRequestConfig) {
        return PublicControllerApiFp(this.configuration).getProblemsByCategory(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicControllerApi
     */
    public getProblemsCount(options?: RawAxiosRequestConfig) {
        return PublicControllerApiFp(this.configuration).getProblemsCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicControllerApi
     */
    public getProblemsUnsorted(options?: RawAxiosRequestConfig) {
        return PublicControllerApiFp(this.configuration).getProblemsUnsorted(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get source by ID. Returns source entity.
     * @summary PUBLIC if approved, USER if owned, ADMIN else
     * @param {string} sourceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicControllerApi
     */
    public getSourceById1(sourceId: string, options?: RawAxiosRequestConfig) {
        return PublicControllerApiFp(this.configuration).getSourceById1(sourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} authorUsername 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicControllerApi
     */
    public getSourcesByAuthor(authorUsername: string, page?: number, size?: number, search?: string, options?: RawAxiosRequestConfig) {
        return PublicControllerApiFp(this.configuration).getSourcesByAuthor(authorUsername, page, size, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicControllerApi
     */
    public getUnsortedProblemsCount(options?: RawAxiosRequestConfig) {
        return PublicControllerApiFp(this.configuration).getUnsortedProblemsCount(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SortControllerApi - axios parameter creator
 * @export
 */
export const SortControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all problems sorted by !author. Returns a list of problems.
         * @summary ADMIN. Get all problems sorted by !author
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotMySortedProblems: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sort/notMySortedProblems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all problems unsorted by !author. Returns a list of problems.
         * @summary ADMIN. Get all problems unsorted by !author
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotMyUnsortedProblems: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sort/notMyUnsortedProblems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all problems sorted by author. Returns a list of problems.
         * @summary USER. Get all problems sorted by author
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSortedProblems: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sort/mySortedProblems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all problems unsorted. Returns a list of problems.
         * @summary USER. Get all problems unsorted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnsortedProblems: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sort/myUnsortedProblems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sort a problem into a category. Returns problem firestore entity.
         * @summary USER owned or ADMIN. Sort a problem into a category
         * @param {string} problemId 
         * @param {CategoryListDto} categoryListDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sortProblem: async (problemId: string, categoryListDto: CategoryListDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'problemId' is not null or undefined
            assertParamExists('sortProblem', 'problemId', problemId)
            // verify required parameter 'categoryListDto' is not null or undefined
            assertParamExists('sortProblem', 'categoryListDto', categoryListDto)
            const localVarPath = `/sort/sort/{problemId}`
                .replace(`{${"problemId"}}`, encodeURIComponent(String(problemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoryListDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SortControllerApi - functional programming interface
 * @export
 */
export const SortControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SortControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all problems sorted by !author. Returns a list of problems.
         * @summary ADMIN. Get all problems sorted by !author
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotMySortedProblems(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProblemDisplayViewDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotMySortedProblems(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SortControllerApi.getNotMySortedProblems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all problems unsorted by !author. Returns a list of problems.
         * @summary ADMIN. Get all problems unsorted by !author
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotMyUnsortedProblems(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProblemDisplayViewDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotMyUnsortedProblems(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SortControllerApi.getNotMyUnsortedProblems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all problems sorted by author. Returns a list of problems.
         * @summary USER. Get all problems sorted by author
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSortedProblems(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProblemDisplayViewDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSortedProblems(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SortControllerApi.getSortedProblems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all problems unsorted. Returns a list of problems.
         * @summary USER. Get all problems unsorted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnsortedProblems(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProblemDisplayViewDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnsortedProblems(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SortControllerApi.getUnsortedProblems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sort a problem into a category. Returns problem firestore entity.
         * @summary USER owned or ADMIN. Sort a problem into a category
         * @param {string} problemId 
         * @param {CategoryListDto} categoryListDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sortProblem(problemId: string, categoryListDto: CategoryListDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Problem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sortProblem(problemId, categoryListDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SortControllerApi.sortProblem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SortControllerApi - factory interface
 * @export
 */
export const SortControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SortControllerApiFp(configuration)
    return {
        /**
         * Get all problems sorted by !author. Returns a list of problems.
         * @summary ADMIN. Get all problems sorted by !author
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotMySortedProblems(options?: any): AxiosPromise<Array<ProblemDisplayViewDto>> {
            return localVarFp.getNotMySortedProblems(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all problems unsorted by !author. Returns a list of problems.
         * @summary ADMIN. Get all problems unsorted by !author
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotMyUnsortedProblems(options?: any): AxiosPromise<Array<ProblemDisplayViewDto>> {
            return localVarFp.getNotMyUnsortedProblems(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all problems sorted by author. Returns a list of problems.
         * @summary USER. Get all problems sorted by author
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSortedProblems(options?: any): AxiosPromise<Array<ProblemDisplayViewDto>> {
            return localVarFp.getSortedProblems(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all problems unsorted. Returns a list of problems.
         * @summary USER. Get all problems unsorted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnsortedProblems(options?: any): AxiosPromise<Array<ProblemDisplayViewDto>> {
            return localVarFp.getUnsortedProblems(options).then((request) => request(axios, basePath));
        },
        /**
         * Sort a problem into a category. Returns problem firestore entity.
         * @summary USER owned or ADMIN. Sort a problem into a category
         * @param {string} problemId 
         * @param {CategoryListDto} categoryListDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sortProblem(problemId: string, categoryListDto: CategoryListDto, options?: any): AxiosPromise<Problem> {
            return localVarFp.sortProblem(problemId, categoryListDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SortControllerApi - object-oriented interface
 * @export
 * @class SortControllerApi
 * @extends {BaseAPI}
 */
export class SortControllerApi extends BaseAPI {
    /**
     * Get all problems sorted by !author. Returns a list of problems.
     * @summary ADMIN. Get all problems sorted by !author
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SortControllerApi
     */
    public getNotMySortedProblems(options?: RawAxiosRequestConfig) {
        return SortControllerApiFp(this.configuration).getNotMySortedProblems(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all problems unsorted by !author. Returns a list of problems.
     * @summary ADMIN. Get all problems unsorted by !author
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SortControllerApi
     */
    public getNotMyUnsortedProblems(options?: RawAxiosRequestConfig) {
        return SortControllerApiFp(this.configuration).getNotMyUnsortedProblems(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all problems sorted by author. Returns a list of problems.
     * @summary USER. Get all problems sorted by author
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SortControllerApi
     */
    public getSortedProblems(options?: RawAxiosRequestConfig) {
        return SortControllerApiFp(this.configuration).getSortedProblems(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all problems unsorted. Returns a list of problems.
     * @summary USER. Get all problems unsorted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SortControllerApi
     */
    public getUnsortedProblems(options?: RawAxiosRequestConfig) {
        return SortControllerApiFp(this.configuration).getUnsortedProblems(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sort a problem into a category. Returns problem firestore entity.
     * @summary USER owned or ADMIN. Sort a problem into a category
     * @param {string} problemId 
     * @param {CategoryListDto} categoryListDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SortControllerApi
     */
    public sortProblem(problemId: string, categoryListDto: CategoryListDto, options?: RawAxiosRequestConfig) {
        return SortControllerApiFp(this.configuration).sortProblem(problemId, categoryListDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SourceControllerApi - axios parameter creator
 * @export
 */
export const SourceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SourcePostDto} sourcePostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSource: async (sourcePostDto: SourcePostDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourcePostDto' is not null or undefined
            assertParamExists('createSource', 'sourcePostDto', sourcePostDto)
            const localVarPath = `/source`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourcePostDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSource', 'id', id)
            const localVarPath = `/source/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSources: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/source`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourceById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSourceById', 'id', id)
            const localVarPath = `/source/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {SourcePostDto} sourcePostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSource: async (id: string, sourcePostDto: SourcePostDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSource', 'id', id)
            // verify required parameter 'sourcePostDto' is not null or undefined
            assertParamExists('updateSource', 'sourcePostDto', sourcePostDto)
            const localVarPath = `/source/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourcePostDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SourceControllerApi - functional programming interface
 * @export
 */
export const SourceControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SourceControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {SourcePostDto} sourcePostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSource(sourcePostDto: SourcePostDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSource(sourcePostDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourceControllerApi.createSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSource(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSource(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourceControllerApi.deleteSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSources(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Source>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllSources(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourceControllerApi.getAllSources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSourceById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSourceById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourceControllerApi.getSourceById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {SourcePostDto} sourcePostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSource(id: string, sourcePostDto: SourcePostDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSource(id, sourcePostDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourceControllerApi.updateSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SourceControllerApi - factory interface
 * @export
 */
export const SourceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SourceControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {SourcePostDto} sourcePostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSource(sourcePostDto: SourcePostDto, options?: any): AxiosPromise<Source> {
            return localVarFp.createSource(sourcePostDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSource(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSources(options?: any): AxiosPromise<Array<Source>> {
            return localVarFp.getAllSources(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourceById(id: string, options?: any): AxiosPromise<Source> {
            return localVarFp.getSourceById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {SourcePostDto} sourcePostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSource(id: string, sourcePostDto: SourcePostDto, options?: any): AxiosPromise<Source> {
            return localVarFp.updateSource(id, sourcePostDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SourceControllerApi - object-oriented interface
 * @export
 * @class SourceControllerApi
 * @extends {BaseAPI}
 */
export class SourceControllerApi extends BaseAPI {
    /**
     * 
     * @param {SourcePostDto} sourcePostDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceControllerApi
     */
    public createSource(sourcePostDto: SourcePostDto, options?: RawAxiosRequestConfig) {
        return SourceControllerApiFp(this.configuration).createSource(sourcePostDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceControllerApi
     */
    public deleteSource(id: string, options?: RawAxiosRequestConfig) {
        return SourceControllerApiFp(this.configuration).deleteSource(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceControllerApi
     */
    public getAllSources(options?: RawAxiosRequestConfig) {
        return SourceControllerApiFp(this.configuration).getAllSources(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceControllerApi
     */
    public getSourceById(id: string, options?: RawAxiosRequestConfig) {
        return SourceControllerApiFp(this.configuration).getSourceById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {SourcePostDto} sourcePostDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceControllerApi
     */
    public updateSource(id: string, sourcePostDto: SourcePostDto, options?: RawAxiosRequestConfig) {
        return SourceControllerApiFp(this.configuration).updateSource(id, sourcePostDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserControllerApi - axios parameter creator
 * @export
 */
export const UserControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary PUBLIC
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBio: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getBio', 'username', username)
            const localVarPath = `/user/bio/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary USER
         * @param {UserBioDto} userBioDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBio: async (userBioDto: UserBioDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userBioDto' is not null or undefined
            assertParamExists('updateBio', 'userBioDto', userBioDto)
            const localVarPath = `/user/bio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userBioDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserControllerApi - functional programming interface
 * @export
 */
export const UserControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary PUBLIC
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBio(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserBioDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBio(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.getBio']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary USER
         * @param {UserBioDto} userBioDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBio(userBioDto: UserBioDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBio(userBioDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.updateBio']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserControllerApi - factory interface
 * @export
 */
export const UserControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary PUBLIC
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBio(username: string, options?: any): AxiosPromise<UserBioDto> {
            return localVarFp.getBio(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary USER
         * @param {UserBioDto} userBioDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBio(userBioDto: UserBioDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateBio(userBioDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserControllerApi - object-oriented interface
 * @export
 * @class UserControllerApi
 * @extends {BaseAPI}
 */
export class UserControllerApi extends BaseAPI {
    /**
     * 
     * @summary PUBLIC
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getBio(username: string, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getBio(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary USER
     * @param {UserBioDto} userBioDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public updateBio(userBioDto: UserBioDto, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).updateBio(userBioDto, options).then((request) => request(this.axios, this.basePath));
    }
}



