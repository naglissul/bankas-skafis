/* tslint:disable */
/* eslint-disable */
/**
 * Skafis užduočių bankas API
 * This is bankas.skafis.lt API. https://api.bankas.skafis.lt
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface CategoriesForAuthor
 */
export interface CategoriesForAuthor {
    /**
     * 
     * @type {Array<UnderReviewCategory>}
     * @memberof CategoriesForAuthor
     */
    'underReviewCategories': Array<UnderReviewCategory>;
    /**
     * 
     * @type {Array<Category>}
     * @memberof CategoriesForAuthor
     */
    'approvedCategories': Array<Category>;
}
/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'author': string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'approvedBy': string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'approvedOn': string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'createdOn': string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'lastModifiedOn': string;
}
/**
 * 
 * @export
 * @interface CategoryPostDto
 */
export interface CategoryPostDto {
    /**
     * 
     * @type {string}
     * @memberof CategoryPostDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryPostDto
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface CountDto
 */
export interface CountDto {
    /**
     * 
     * @type {number}
     * @memberof CountDto
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface FixMyUnderReviewProblemRequest
 */
export interface FixMyUnderReviewProblemRequest {
    /**
     * 
     * @type {string}
     * @memberof FixMyUnderReviewProblemRequest
     */
    'problem': string;
    /**
     * 
     * @type {File}
     * @memberof FixMyUnderReviewProblemRequest
     */
    'problemImageFile'?: File;
    /**
     * 
     * @type {File}
     * @memberof FixMyUnderReviewProblemRequest
     */
    'answerImageFile'?: File;
}
/**
 * 
 * @export
 * @interface Problem
 */
export interface Problem {
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'skfCode': string;
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'problemText': string;
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'problemImagePath': string;
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'answerText': string;
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'answerImagePath': string;
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'categoryId': string;
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'author': string;
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'approvedBy': string;
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'approvedOn': string;
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'createdOn': string;
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'lastModifiedOn': string;
}
/**
 * 
 * @export
 * @interface ProblemDisplayViewDto
 */
export interface ProblemDisplayViewDto {
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'skfCode': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'problemText': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'problemImageSrc': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'answerText': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'answerImageSrc': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'categoryId': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'author': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'approvedBy': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'approvedOn': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'createdOn': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'lastModifiedOn': string;
}
/**
 * 
 * @export
 * @interface ProblemsForAuthor
 */
export interface ProblemsForAuthor {
    /**
     * 
     * @type {Array<UnderReviewProblemDisplayViewDto>}
     * @memberof ProblemsForAuthor
     */
    'underReviewProblems': Array<UnderReviewProblemDisplayViewDto>;
    /**
     * 
     * @type {Array<ProblemDisplayViewDto>}
     * @memberof ProblemsForAuthor
     */
    'approvedProblems': Array<ProblemDisplayViewDto>;
}
/**
 * 
 * @export
 * @interface RejectMsgDto
 */
export interface RejectMsgDto {
    /**
     * 
     * @type {string}
     * @memberof RejectMsgDto
     */
    'rejectionMessage': string;
}
/**
 * 
 * @export
 * @interface UnderReviewCategory
 */
export interface UnderReviewCategory {
    /**
     * 
     * @type {string}
     * @memberof UnderReviewCategory
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewCategory
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewCategory
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewCategory
     */
    'author': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewCategory
     */
    'createdOn': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewCategory
     */
    'lastModifiedOn': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewCategory
     */
    'reviewStatus': UnderReviewCategoryReviewStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewCategory
     */
    'rejectedBy': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewCategory
     */
    'rejectedOn': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewCategory
     */
    'rejectionMessage': string;
}

export const UnderReviewCategoryReviewStatusEnum = {
    Pending: 'PENDING',
    Rejected: 'REJECTED'
} as const;

export type UnderReviewCategoryReviewStatusEnum = typeof UnderReviewCategoryReviewStatusEnum[keyof typeof UnderReviewCategoryReviewStatusEnum];

/**
 * 
 * @export
 * @interface UnderReviewProblem
 */
export interface UnderReviewProblem {
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblem
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblem
     */
    'problemText': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblem
     */
    'answerText': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblem
     */
    'problemImagePath': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblem
     */
    'answerImagePath': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblem
     */
    'categoryId': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblem
     */
    'author': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblem
     */
    'createdOn': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblem
     */
    'lastModifiedOn': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblem
     */
    'reviewStatus': UnderReviewProblemReviewStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblem
     */
    'rejectedBy': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblem
     */
    'rejectedOn': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblem
     */
    'rejectionMessage': string;
}

export const UnderReviewProblemReviewStatusEnum = {
    Pending: 'PENDING',
    Rejected: 'REJECTED'
} as const;

export type UnderReviewProblemReviewStatusEnum = typeof UnderReviewProblemReviewStatusEnum[keyof typeof UnderReviewProblemReviewStatusEnum];

/**
 * 
 * @export
 * @interface UnderReviewProblemDisplayViewDto
 */
export interface UnderReviewProblemDisplayViewDto {
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblemDisplayViewDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblemDisplayViewDto
     */
    'problemText': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblemDisplayViewDto
     */
    'answerText': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblemDisplayViewDto
     */
    'problemImageSrc': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblemDisplayViewDto
     */
    'answerImageSrc': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblemDisplayViewDto
     */
    'categoryId': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblemDisplayViewDto
     */
    'author': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblemDisplayViewDto
     */
    'createdOn': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblemDisplayViewDto
     */
    'lastModifiedOn': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblemDisplayViewDto
     */
    'reviewStatus': UnderReviewProblemDisplayViewDtoReviewStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblemDisplayViewDto
     */
    'rejectedBy': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblemDisplayViewDto
     */
    'rejectedOn': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblemDisplayViewDto
     */
    'rejectionMessage': string;
}

export const UnderReviewProblemDisplayViewDtoReviewStatusEnum = {
    Pending: 'PENDING',
    Rejected: 'REJECTED'
} as const;

export type UnderReviewProblemDisplayViewDtoReviewStatusEnum = typeof UnderReviewProblemDisplayViewDtoReviewStatusEnum[keyof typeof UnderReviewProblemDisplayViewDtoReviewStatusEnum];

/**
 * 
 * @export
 * @interface UserBioDto
 */
export interface UserBioDto {
    /**
     * 
     * @type {string}
     * @memberof UserBioDto
     */
    'bio': string;
}

/**
 * CategoryControllerApi - axios parameter creator
 * @export
 */
export const CategoryControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Works. ADMIN
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveCategory: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('approveCategory', 'id', id)
            const localVarPath = `/category/{id}/approve`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Works. USER
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUnderReviewCategory: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUnderReviewCategory', 'id', id)
            const localVarPath = `/category/underReview/{id}/cascade`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Works. PUBLIC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPublicCategories: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Works. USER
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyAllSubmittedCategories: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/category/myAllSubmitted`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Works. PUBLIC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicCategoriesCount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/category/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Works. PUBLIC
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicCategory: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPublicCategory', 'id', id)
            const localVarPath = `/category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Works. ADMIN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmittedCategories: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/category/underReview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Works. ADMIN
         * @param {string} id 
         * @param {RejectMsgDto} rejectMsgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectCategory: async (id: string, rejectMsgDto: RejectMsgDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rejectCategory', 'id', id)
            // verify required parameter 'rejectMsgDto' is not null or undefined
            assertParamExists('rejectCategory', 'rejectMsgDto', rejectMsgDto)
            const localVarPath = `/category/{id}/reject`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rejectMsgDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Works. USER
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitCategory: async (categoryPostDto: CategoryPostDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryPostDto' is not null or undefined
            assertParamExists('submitCategory', 'categoryPostDto', categoryPostDto)
            const localVarPath = `/category/submit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoryPostDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Works. USER
         * @param {string} id 
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory: async (id: string, categoryPostDto: CategoryPostDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCategory', 'id', id)
            // verify required parameter 'categoryPostDto' is not null or undefined
            assertParamExists('updateCategory', 'categoryPostDto', categoryPostDto)
            const localVarPath = `/category/{id}/fixMyUnderReview`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoryPostDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoryControllerApi - functional programming interface
 * @export
 */
export const CategoryControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoryControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Works. ADMIN
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveCategory(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveCategory(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerApi.approveCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Works. USER
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUnderReviewCategory(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUnderReviewCategory(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerApi.deleteUnderReviewCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Works. PUBLIC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPublicCategories(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Category>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPublicCategories(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerApi.getAllPublicCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Works. USER
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyAllSubmittedCategories(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoriesForAuthor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyAllSubmittedCategories(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerApi.getMyAllSubmittedCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Works. PUBLIC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicCategoriesCount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicCategoriesCount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerApi.getPublicCategoriesCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Works. PUBLIC
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicCategory(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicCategory(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerApi.getPublicCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Works. ADMIN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubmittedCategories(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UnderReviewCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubmittedCategories(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerApi.getSubmittedCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Works. ADMIN
         * @param {string} id 
         * @param {RejectMsgDto} rejectMsgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectCategory(id: string, rejectMsgDto: RejectMsgDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnderReviewCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectCategory(id, rejectMsgDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerApi.rejectCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Works. USER
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitCategory(categoryPostDto: CategoryPostDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnderReviewCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitCategory(categoryPostDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerApi.submitCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Works. USER
         * @param {string} id 
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCategory(id: string, categoryPostDto: CategoryPostDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnderReviewCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCategory(id, categoryPostDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerApi.updateCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CategoryControllerApi - factory interface
 * @export
 */
export const CategoryControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoryControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary Works. ADMIN
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveCategory(id: string, options?: any): AxiosPromise<Category> {
            return localVarFp.approveCategory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Works. USER
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUnderReviewCategory(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUnderReviewCategory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Works. PUBLIC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPublicCategories(options?: any): AxiosPromise<Array<Category>> {
            return localVarFp.getAllPublicCategories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Works. USER
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyAllSubmittedCategories(options?: any): AxiosPromise<CategoriesForAuthor> {
            return localVarFp.getMyAllSubmittedCategories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Works. PUBLIC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicCategoriesCount(options?: any): AxiosPromise<CountDto> {
            return localVarFp.getPublicCategoriesCount(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Works. PUBLIC
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicCategory(id: string, options?: any): AxiosPromise<Category> {
            return localVarFp.getPublicCategory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Works. ADMIN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmittedCategories(options?: any): AxiosPromise<Array<UnderReviewCategory>> {
            return localVarFp.getSubmittedCategories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Works. ADMIN
         * @param {string} id 
         * @param {RejectMsgDto} rejectMsgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectCategory(id: string, rejectMsgDto: RejectMsgDto, options?: any): AxiosPromise<UnderReviewCategory> {
            return localVarFp.rejectCategory(id, rejectMsgDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Works. USER
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitCategory(categoryPostDto: CategoryPostDto, options?: any): AxiosPromise<UnderReviewCategory> {
            return localVarFp.submitCategory(categoryPostDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Works. USER
         * @param {string} id 
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory(id: string, categoryPostDto: CategoryPostDto, options?: any): AxiosPromise<UnderReviewCategory> {
            return localVarFp.updateCategory(id, categoryPostDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoryControllerApi - object-oriented interface
 * @export
 * @class CategoryControllerApi
 * @extends {BaseAPI}
 */
export class CategoryControllerApi extends BaseAPI {
    /**
     * 
     * @summary Works. ADMIN
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public approveCategory(id: string, options?: RawAxiosRequestConfig) {
        return CategoryControllerApiFp(this.configuration).approveCategory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Works. USER
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public deleteUnderReviewCategory(id: string, options?: RawAxiosRequestConfig) {
        return CategoryControllerApiFp(this.configuration).deleteUnderReviewCategory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Works. PUBLIC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public getAllPublicCategories(options?: RawAxiosRequestConfig) {
        return CategoryControllerApiFp(this.configuration).getAllPublicCategories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Works. USER
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public getMyAllSubmittedCategories(options?: RawAxiosRequestConfig) {
        return CategoryControllerApiFp(this.configuration).getMyAllSubmittedCategories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Works. PUBLIC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public getPublicCategoriesCount(options?: RawAxiosRequestConfig) {
        return CategoryControllerApiFp(this.configuration).getPublicCategoriesCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Works. PUBLIC
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public getPublicCategory(id: string, options?: RawAxiosRequestConfig) {
        return CategoryControllerApiFp(this.configuration).getPublicCategory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Works. ADMIN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public getSubmittedCategories(options?: RawAxiosRequestConfig) {
        return CategoryControllerApiFp(this.configuration).getSubmittedCategories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Works. ADMIN
     * @param {string} id 
     * @param {RejectMsgDto} rejectMsgDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public rejectCategory(id: string, rejectMsgDto: RejectMsgDto, options?: RawAxiosRequestConfig) {
        return CategoryControllerApiFp(this.configuration).rejectCategory(id, rejectMsgDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Works. USER
     * @param {CategoryPostDto} categoryPostDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public submitCategory(categoryPostDto: CategoryPostDto, options?: RawAxiosRequestConfig) {
        return CategoryControllerApiFp(this.configuration).submitCategory(categoryPostDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Works. USER
     * @param {string} id 
     * @param {CategoryPostDto} categoryPostDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public updateCategory(id: string, categoryPostDto: CategoryPostDto, options?: RawAxiosRequestConfig) {
        return CategoryControllerApiFp(this.configuration).updateCategory(id, categoryPostDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProblemControllerApi - axios parameter creator
 * @export
 */
export const ProblemControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Works. ADMIN
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveProblem: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('approveProblem', 'id', id)
            const localVarPath = `/problem/{id}/approve`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Works. USER
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUnderReviewProblem: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUnderReviewProblem', 'id', id)
            const localVarPath = `/problem/underReview/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Works. USER
         * @param {string} id 
         * @param {FixMyUnderReviewProblemRequest} [fixMyUnderReviewProblemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fixMyUnderReviewProblem: async (id: string, fixMyUnderReviewProblemRequest?: FixMyUnderReviewProblemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fixMyUnderReviewProblem', 'id', id)
            const localVarPath = `/problem/{id}/fixMyUnderReview`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fixMyUnderReviewProblemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Works. ADMIN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUnderReviewProblems: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/problem/underReview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Works. USER
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyAllSubmittedProblems: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/problem/myAllSubmitted`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Works. PUBLIC
         * @param {string} skfCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicProblem: async (skfCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'skfCode' is not null or undefined
            assertParamExists('getPublicProblem', 'skfCode', skfCode)
            const localVarPath = `/problem/{skfCode}`
                .replace(`{${"skfCode"}}`, encodeURIComponent(String(skfCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Works. PUBLIC
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicProblemsByCategory: async (categoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getPublicProblemsByCategory', 'categoryId', categoryId)
            const localVarPath = `/problem/byCategory/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Works. PUBLIC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicProblemsCount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/problem/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Works. ADMIN
         * @param {string} id 
         * @param {RejectMsgDto} rejectMsgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectProblem: async (id: string, rejectMsgDto: RejectMsgDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rejectProblem', 'id', id)
            // verify required parameter 'rejectMsgDto' is not null or undefined
            assertParamExists('rejectProblem', 'rejectMsgDto', rejectMsgDto)
            const localVarPath = `/problem/{id}/reject`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rejectMsgDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *              This endpoint allows uploading problem information as JSON along with optional image files.              **Request Type**: `multipart/form-data`             - Key `problem`: JSON string containing the problem information             - Key `problemImageFile`: (optional) Image file associated with the problem             - Key `answerImageFile`: (optional) Image file associated with the answer              **Logic**:             - If `problem.problemImageUrl` is a URL and `problemImageFile` is null, return `problemImagePath = problem.problemImage`.             - If `problem.problemImageUrl` is \"\" and `problemImageFile` is provided, upload the file and return `problemImagePath = \"problems/SKF-...\"`.             - If `problem.problemImageUrl` is \"\" and `problemImageFile` is null, return `problemImagePath = \"\"`.         
         * @summary Works. USER. Careful! Complex file and text upload logic AND not easily testable file upload!
         * @param {FixMyUnderReviewProblemRequest} [fixMyUnderReviewProblemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitProblem: async (fixMyUnderReviewProblemRequest?: FixMyUnderReviewProblemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/problem/submit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fixMyUnderReviewProblemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProblemControllerApi - functional programming interface
 * @export
 */
export const ProblemControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProblemControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Works. ADMIN
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveProblem(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Problem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveProblem(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProblemControllerApi.approveProblem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Works. USER
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUnderReviewProblem(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUnderReviewProblem(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProblemControllerApi.deleteUnderReviewProblem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Works. USER
         * @param {string} id 
         * @param {FixMyUnderReviewProblemRequest} [fixMyUnderReviewProblemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fixMyUnderReviewProblem(id: string, fixMyUnderReviewProblemRequest?: FixMyUnderReviewProblemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnderReviewProblem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fixMyUnderReviewProblem(id, fixMyUnderReviewProblemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProblemControllerApi.fixMyUnderReviewProblem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Works. ADMIN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUnderReviewProblems(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UnderReviewProblemDisplayViewDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUnderReviewProblems(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProblemControllerApi.getAllUnderReviewProblems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Works. USER
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyAllSubmittedProblems(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProblemsForAuthor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyAllSubmittedProblems(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProblemControllerApi.getMyAllSubmittedProblems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Works. PUBLIC
         * @param {string} skfCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicProblem(skfCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProblemDisplayViewDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicProblem(skfCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProblemControllerApi.getPublicProblem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Works. PUBLIC
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicProblemsByCategory(categoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProblemDisplayViewDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicProblemsByCategory(categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProblemControllerApi.getPublicProblemsByCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Works. PUBLIC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicProblemsCount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicProblemsCount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProblemControllerApi.getPublicProblemsCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Works. ADMIN
         * @param {string} id 
         * @param {RejectMsgDto} rejectMsgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectProblem(id: string, rejectMsgDto: RejectMsgDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnderReviewProblem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectProblem(id, rejectMsgDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProblemControllerApi.rejectProblem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *              This endpoint allows uploading problem information as JSON along with optional image files.              **Request Type**: `multipart/form-data`             - Key `problem`: JSON string containing the problem information             - Key `problemImageFile`: (optional) Image file associated with the problem             - Key `answerImageFile`: (optional) Image file associated with the answer              **Logic**:             - If `problem.problemImageUrl` is a URL and `problemImageFile` is null, return `problemImagePath = problem.problemImage`.             - If `problem.problemImageUrl` is \"\" and `problemImageFile` is provided, upload the file and return `problemImagePath = \"problems/SKF-...\"`.             - If `problem.problemImageUrl` is \"\" and `problemImageFile` is null, return `problemImagePath = \"\"`.         
         * @summary Works. USER. Careful! Complex file and text upload logic AND not easily testable file upload!
         * @param {FixMyUnderReviewProblemRequest} [fixMyUnderReviewProblemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitProblem(fixMyUnderReviewProblemRequest?: FixMyUnderReviewProblemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnderReviewProblem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitProblem(fixMyUnderReviewProblemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProblemControllerApi.submitProblem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProblemControllerApi - factory interface
 * @export
 */
export const ProblemControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProblemControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary Works. ADMIN
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveProblem(id: string, options?: any): AxiosPromise<Problem> {
            return localVarFp.approveProblem(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Works. USER
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUnderReviewProblem(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUnderReviewProblem(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Works. USER
         * @param {string} id 
         * @param {FixMyUnderReviewProblemRequest} [fixMyUnderReviewProblemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fixMyUnderReviewProblem(id: string, fixMyUnderReviewProblemRequest?: FixMyUnderReviewProblemRequest, options?: any): AxiosPromise<UnderReviewProblem> {
            return localVarFp.fixMyUnderReviewProblem(id, fixMyUnderReviewProblemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Works. ADMIN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUnderReviewProblems(options?: any): AxiosPromise<Array<UnderReviewProblemDisplayViewDto>> {
            return localVarFp.getAllUnderReviewProblems(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Works. USER
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyAllSubmittedProblems(options?: any): AxiosPromise<ProblemsForAuthor> {
            return localVarFp.getMyAllSubmittedProblems(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Works. PUBLIC
         * @param {string} skfCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicProblem(skfCode: string, options?: any): AxiosPromise<ProblemDisplayViewDto> {
            return localVarFp.getPublicProblem(skfCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Works. PUBLIC
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicProblemsByCategory(categoryId: string, options?: any): AxiosPromise<Array<ProblemDisplayViewDto>> {
            return localVarFp.getPublicProblemsByCategory(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Works. PUBLIC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicProblemsCount(options?: any): AxiosPromise<CountDto> {
            return localVarFp.getPublicProblemsCount(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Works. ADMIN
         * @param {string} id 
         * @param {RejectMsgDto} rejectMsgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectProblem(id: string, rejectMsgDto: RejectMsgDto, options?: any): AxiosPromise<UnderReviewProblem> {
            return localVarFp.rejectProblem(id, rejectMsgDto, options).then((request) => request(axios, basePath));
        },
        /**
         *              This endpoint allows uploading problem information as JSON along with optional image files.              **Request Type**: `multipart/form-data`             - Key `problem`: JSON string containing the problem information             - Key `problemImageFile`: (optional) Image file associated with the problem             - Key `answerImageFile`: (optional) Image file associated with the answer              **Logic**:             - If `problem.problemImageUrl` is a URL and `problemImageFile` is null, return `problemImagePath = problem.problemImage`.             - If `problem.problemImageUrl` is \"\" and `problemImageFile` is provided, upload the file and return `problemImagePath = \"problems/SKF-...\"`.             - If `problem.problemImageUrl` is \"\" and `problemImageFile` is null, return `problemImagePath = \"\"`.         
         * @summary Works. USER. Careful! Complex file and text upload logic AND not easily testable file upload!
         * @param {FixMyUnderReviewProblemRequest} [fixMyUnderReviewProblemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitProblem(fixMyUnderReviewProblemRequest?: FixMyUnderReviewProblemRequest, options?: any): AxiosPromise<UnderReviewProblem> {
            return localVarFp.submitProblem(fixMyUnderReviewProblemRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProblemControllerApi - object-oriented interface
 * @export
 * @class ProblemControllerApi
 * @extends {BaseAPI}
 */
export class ProblemControllerApi extends BaseAPI {
    /**
     * 
     * @summary Works. ADMIN
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProblemControllerApi
     */
    public approveProblem(id: string, options?: RawAxiosRequestConfig) {
        return ProblemControllerApiFp(this.configuration).approveProblem(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Works. USER
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProblemControllerApi
     */
    public deleteUnderReviewProblem(id: string, options?: RawAxiosRequestConfig) {
        return ProblemControllerApiFp(this.configuration).deleteUnderReviewProblem(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Works. USER
     * @param {string} id 
     * @param {FixMyUnderReviewProblemRequest} [fixMyUnderReviewProblemRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProblemControllerApi
     */
    public fixMyUnderReviewProblem(id: string, fixMyUnderReviewProblemRequest?: FixMyUnderReviewProblemRequest, options?: RawAxiosRequestConfig) {
        return ProblemControllerApiFp(this.configuration).fixMyUnderReviewProblem(id, fixMyUnderReviewProblemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Works. ADMIN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProblemControllerApi
     */
    public getAllUnderReviewProblems(options?: RawAxiosRequestConfig) {
        return ProblemControllerApiFp(this.configuration).getAllUnderReviewProblems(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Works. USER
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProblemControllerApi
     */
    public getMyAllSubmittedProblems(options?: RawAxiosRequestConfig) {
        return ProblemControllerApiFp(this.configuration).getMyAllSubmittedProblems(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Works. PUBLIC
     * @param {string} skfCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProblemControllerApi
     */
    public getPublicProblem(skfCode: string, options?: RawAxiosRequestConfig) {
        return ProblemControllerApiFp(this.configuration).getPublicProblem(skfCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Works. PUBLIC
     * @param {string} categoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProblemControllerApi
     */
    public getPublicProblemsByCategory(categoryId: string, options?: RawAxiosRequestConfig) {
        return ProblemControllerApiFp(this.configuration).getPublicProblemsByCategory(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Works. PUBLIC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProblemControllerApi
     */
    public getPublicProblemsCount(options?: RawAxiosRequestConfig) {
        return ProblemControllerApiFp(this.configuration).getPublicProblemsCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Works. ADMIN
     * @param {string} id 
     * @param {RejectMsgDto} rejectMsgDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProblemControllerApi
     */
    public rejectProblem(id: string, rejectMsgDto: RejectMsgDto, options?: RawAxiosRequestConfig) {
        return ProblemControllerApiFp(this.configuration).rejectProblem(id, rejectMsgDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *              This endpoint allows uploading problem information as JSON along with optional image files.              **Request Type**: `multipart/form-data`             - Key `problem`: JSON string containing the problem information             - Key `problemImageFile`: (optional) Image file associated with the problem             - Key `answerImageFile`: (optional) Image file associated with the answer              **Logic**:             - If `problem.problemImageUrl` is a URL and `problemImageFile` is null, return `problemImagePath = problem.problemImage`.             - If `problem.problemImageUrl` is \"\" and `problemImageFile` is provided, upload the file and return `problemImagePath = \"problems/SKF-...\"`.             - If `problem.problemImageUrl` is \"\" and `problemImageFile` is null, return `problemImagePath = \"\"`.         
     * @summary Works. USER. Careful! Complex file and text upload logic AND not easily testable file upload!
     * @param {FixMyUnderReviewProblemRequest} [fixMyUnderReviewProblemRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProblemControllerApi
     */
    public submitProblem(fixMyUnderReviewProblemRequest?: FixMyUnderReviewProblemRequest, options?: RawAxiosRequestConfig) {
        return ProblemControllerApiFp(this.configuration).submitProblem(fixMyUnderReviewProblemRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TestControllerApi - axios parameter creator
 * @export
 */
export const TestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/test/getUserId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestControllerApi - functional programming interface
 * @export
 */
export const TestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async test(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.test(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestControllerApi.test']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TestControllerApi - factory interface
 * @export
 */
export const TestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test(options?: any): AxiosPromise<string> {
            return localVarFp.test(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestControllerApi - object-oriented interface
 * @export
 * @class TestControllerApi
 * @extends {BaseAPI}
 */
export class TestControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestControllerApi
     */
    public test(options?: RawAxiosRequestConfig) {
        return TestControllerApiFp(this.configuration).test(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserControllerApi - axios parameter creator
 * @export
 */
export const UserControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Works. PUBLIC
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBio: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getBio', 'username', username)
            const localVarPath = `/user/bio/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Works. USER
         * @param {UserBioDto} userBioDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBio: async (userBioDto: UserBioDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userBioDto' is not null or undefined
            assertParamExists('updateBio', 'userBioDto', userBioDto)
            const localVarPath = `/user/bio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userBioDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserControllerApi - functional programming interface
 * @export
 */
export const UserControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Works. PUBLIC
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBio(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserBioDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBio(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.getBio']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Works. USER
         * @param {UserBioDto} userBioDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBio(userBioDto: UserBioDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBio(userBioDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.updateBio']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserControllerApi - factory interface
 * @export
 */
export const UserControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary Works. PUBLIC
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBio(username: string, options?: any): AxiosPromise<UserBioDto> {
            return localVarFp.getBio(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Works. USER
         * @param {UserBioDto} userBioDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBio(userBioDto: UserBioDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateBio(userBioDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserControllerApi - object-oriented interface
 * @export
 * @class UserControllerApi
 * @extends {BaseAPI}
 */
export class UserControllerApi extends BaseAPI {
    /**
     * 
     * @summary Works. PUBLIC
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getBio(username: string, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getBio(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Works. USER
     * @param {UserBioDto} userBioDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public updateBio(userBioDto: UserBioDto, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).updateBio(userBioDto, options).then((request) => request(this.axios, this.basePath));
    }
}



