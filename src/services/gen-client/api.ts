/* tslint:disable */
/* eslint-disable */
/**
 * Skafis užduočių bankas API
 * This is bankas.skafis.lt API. https://api.bankas.skafis.lt
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface CategoryPostDto
 */
export interface CategoryPostDto {
    /**
     * 
     * @type {string}
     * @memberof CategoryPostDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryPostDto
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface CountDto
 */
export interface CountDto {
    /**
     * 
     * @type {number}
     * @memberof CountDto
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface FixMyUnderReviewProblemRequest
 */
export interface FixMyUnderReviewProblemRequest {
    /**
     * 
     * @type {ProblemPostDtoOld}
     * @memberof FixMyUnderReviewProblemRequest
     */
    'problem': ProblemPostDtoOld;
    /**
     * 
     * @type {File}
     * @memberof FixMyUnderReviewProblemRequest
     */
    'problemImageFile'?: File;
    /**
     * 
     * @type {File}
     * @memberof FixMyUnderReviewProblemRequest
     */
    'answerImageFile'?: File;
}
/**
 * 
 * @export
 * @interface IdDto
 */
export interface IdDto {
    /**
     * 
     * @type {string}
     * @memberof IdDto
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface Problem
 */
export interface Problem {
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'skfCode': string;
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'problemText': string;
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'problemImagePath': string;
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'answerText': string;
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'answerImagePath': string;
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'categoryId': string;
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'sourceId': string;
    /**
     * 
     * @type {boolean}
     * @memberof Problem
     */
    'isApproved': boolean;
}
/**
 * 
 * @export
 * @interface ProblemDisplayViewDto
 */
export interface ProblemDisplayViewDto {
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'skfCode': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'problemText': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'problemImageSrc': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'answerText': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'answerImageSrc': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'categoryId': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDisplayViewDto
     */
    'sourceId': string;
}
/**
 * 
 * @export
 * @interface ProblemPostDto
 */
export interface ProblemPostDto {
    /**
     * 
     * @type {string}
     * @memberof ProblemPostDto
     */
    'skfCode': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemPostDto
     */
    'problemImagePath': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemPostDto
     */
    'answerImagePath': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemPostDto
     */
    'problemText': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemPostDto
     */
    'answerText': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemPostDto
     */
    'categoryId': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemPostDto
     */
    'sourceId': string;
}
/**
 * 
 * @export
 * @interface ProblemPostDtoOld
 */
export interface ProblemPostDtoOld {
    /**
     * 
     * @type {string}
     * @memberof ProblemPostDtoOld
     */
    'problemImageUrl': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemPostDtoOld
     */
    'answerImageUrl': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemPostDtoOld
     */
    'problemText': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemPostDtoOld
     */
    'answerText': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemPostDtoOld
     */
    'categoryId': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemPostDtoOld
     */
    'sourceId': string;
}
/**
 * 
 * @export
 * @interface ProblemSubmitDto
 */
export interface ProblemSubmitDto {
    /**
     * 
     * @type {string}
     * @memberof ProblemSubmitDto
     */
    'problemImageUrl': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemSubmitDto
     */
    'answerImageUrl': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemSubmitDto
     */
    'problemText': string;
    /**
     * 
     * @type {string}
     * @memberof ProblemSubmitDto
     */
    'answerText': string;
}
/**
 * 
 * @export
 * @interface ProblemsForAuthor
 */
export interface ProblemsForAuthor {
    /**
     * 
     * @type {Array<UnderReviewProblemDisplayViewDto>}
     * @memberof ProblemsForAuthor
     */
    'underReviewProblems': Array<UnderReviewProblemDisplayViewDto>;
    /**
     * 
     * @type {Array<ProblemDisplayViewDto>}
     * @memberof ProblemsForAuthor
     */
    'approvedProblems': Array<ProblemDisplayViewDto>;
}
/**
 * 
 * @export
 * @interface RejectMsgDto
 */
export interface RejectMsgDto {
    /**
     * 
     * @type {string}
     * @memberof RejectMsgDto
     */
    'reviewMessage': string;
}
/**
 * 
 * @export
 * @interface Source
 */
export interface Source {
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'reviewStatus': SourceReviewStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'reviewedBy': string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'reviewedOn': string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'reviewMessage': string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'author': string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'createdOn': string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'lastModifiedOn': string;
}

export const SourceReviewStatusEnum = {
    Pending: 'PENDING',
    Rejected: 'REJECTED',
    Approved: 'APPROVED'
} as const;

export type SourceReviewStatusEnum = typeof SourceReviewStatusEnum[keyof typeof SourceReviewStatusEnum];

/**
 * 
 * @export
 * @interface SourcePostDto
 */
export interface SourcePostDto {
    /**
     * 
     * @type {string}
     * @memberof SourcePostDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SourcePostDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof SourcePostDto
     */
    'reviewStatus': SourcePostDtoReviewStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof SourcePostDto
     */
    'reviewedBy': string;
    /**
     * 
     * @type {string}
     * @memberof SourcePostDto
     */
    'reviewedOn': string;
    /**
     * 
     * @type {string}
     * @memberof SourcePostDto
     */
    'reviewMessage': string;
    /**
     * 
     * @type {string}
     * @memberof SourcePostDto
     */
    'author': string;
    /**
     * 
     * @type {string}
     * @memberof SourcePostDto
     */
    'createdOn': string;
    /**
     * 
     * @type {string}
     * @memberof SourcePostDto
     */
    'lastModifiedOn': string;
}

export const SourcePostDtoReviewStatusEnum = {
    Pending: 'PENDING',
    Rejected: 'REJECTED',
    Approved: 'APPROVED'
} as const;

export type SourcePostDtoReviewStatusEnum = typeof SourcePostDtoReviewStatusEnum[keyof typeof SourcePostDtoReviewStatusEnum];

/**
 * 
 * @export
 * @interface SourceSubmitDto
 */
export interface SourceSubmitDto {
    /**
     * 
     * @type {string}
     * @memberof SourceSubmitDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SourceSubmitDto
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface UnderReviewCategory
 */
export interface UnderReviewCategory {
    /**
     * 
     * @type {string}
     * @memberof UnderReviewCategory
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewCategory
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewCategory
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewCategory
     */
    'author': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewCategory
     */
    'createdOn': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewCategory
     */
    'lastModifiedOn': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewCategory
     */
    'reviewStatus': UnderReviewCategoryReviewStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewCategory
     */
    'rejectedBy': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewCategory
     */
    'rejectedOn': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewCategory
     */
    'rejectionMessage': string;
}

export const UnderReviewCategoryReviewStatusEnum = {
    Pending: 'PENDING',
    Rejected: 'REJECTED',
    Approved: 'APPROVED'
} as const;

export type UnderReviewCategoryReviewStatusEnum = typeof UnderReviewCategoryReviewStatusEnum[keyof typeof UnderReviewCategoryReviewStatusEnum];

/**
 * 
 * @export
 * @interface UnderReviewProblem
 */
export interface UnderReviewProblem {
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblem
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblem
     */
    'problemText': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblem
     */
    'answerText': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblem
     */
    'problemImagePath': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblem
     */
    'answerImagePath': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblem
     */
    'categoryId': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblem
     */
    'author': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblem
     */
    'createdOn': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblem
     */
    'lastModifiedOn': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblem
     */
    'reviewStatus': UnderReviewProblemReviewStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblem
     */
    'rejectedBy': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblem
     */
    'rejectedOn': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblem
     */
    'rejectionMessage': string;
}

export const UnderReviewProblemReviewStatusEnum = {
    Pending: 'PENDING',
    Rejected: 'REJECTED',
    Approved: 'APPROVED'
} as const;

export type UnderReviewProblemReviewStatusEnum = typeof UnderReviewProblemReviewStatusEnum[keyof typeof UnderReviewProblemReviewStatusEnum];

/**
 * 
 * @export
 * @interface UnderReviewProblemDisplayViewDto
 */
export interface UnderReviewProblemDisplayViewDto {
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblemDisplayViewDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblemDisplayViewDto
     */
    'problemText': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblemDisplayViewDto
     */
    'answerText': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblemDisplayViewDto
     */
    'problemImageSrc': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblemDisplayViewDto
     */
    'answerImageSrc': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblemDisplayViewDto
     */
    'categoryId': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblemDisplayViewDto
     */
    'author': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblemDisplayViewDto
     */
    'createdOn': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblemDisplayViewDto
     */
    'lastModifiedOn': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblemDisplayViewDto
     */
    'reviewStatus': UnderReviewProblemDisplayViewDtoReviewStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblemDisplayViewDto
     */
    'rejectedBy': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblemDisplayViewDto
     */
    'rejectedOn': string;
    /**
     * 
     * @type {string}
     * @memberof UnderReviewProblemDisplayViewDto
     */
    'rejectionMessage': string;
}

export const UnderReviewProblemDisplayViewDtoReviewStatusEnum = {
    Pending: 'PENDING',
    Rejected: 'REJECTED',
    Approved: 'APPROVED'
} as const;

export type UnderReviewProblemDisplayViewDtoReviewStatusEnum = typeof UnderReviewProblemDisplayViewDtoReviewStatusEnum[keyof typeof UnderReviewProblemDisplayViewDtoReviewStatusEnum];

/**
 * 
 * @export
 * @interface UserBioDto
 */
export interface UserBioDto {
    /**
     * 
     * @type {string}
     * @memberof UserBioDto
     */
    'bio': string;
}

/**
 * ApprovalControllerApi - axios parameter creator
 * @export
 */
export const ApprovalControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all sources submitted by the current user.
         * @summary USER. Get my sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMySources: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/approval/mySources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all problems submitted for the source.
         * @summary Either USER with it\'s problems, or ADMIN, or PUBLIC && source.reviewStatus === ReviewStatus.APPROVED. Get problems by source
         * @param {string} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProblemsBySource: async (sourceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('getProblemsBySource', 'sourceId', sourceId)
            const localVarPath = `/approval/problemsBySource/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Doesn\'t work from swagger... responds with 415. Submit problem data with images for approval. Returns the ID of the created problem.
         * @summary USER. Submit problem data with images
         * @param {string} sourceId 
         * @param {ProblemSubmitDto} problem 
         * @param {File} [problemImageFile] 
         * @param {File} [answerImageFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitProblem1: async (sourceId: string, problem: ProblemSubmitDto, problemImageFile?: File, answerImageFile?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceId' is not null or undefined
            assertParamExists('submitProblem1', 'sourceId', sourceId)
            // verify required parameter 'problem' is not null or undefined
            assertParamExists('submitProblem1', 'problem', problem)
            const localVarPath = `/approval/submit/problem/{sourceId}`
                .replace(`{${"sourceId"}}`, encodeURIComponent(String(sourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (problem !== undefined) { 
                localVarFormParams.append('problem', new Blob([JSON.stringify(problem)], { type: "application/json", }));
            }
    
            if (problemImageFile !== undefined) { 
                localVarFormParams.append('problemImageFile', problemImageFile as any);
            }
    
            if (answerImageFile !== undefined) { 
                localVarFormParams.append('answerImageFile', answerImageFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit source data for approval. Returns the ID of the created source.
         * @summary USER. Submit source data
         * @param {SourceSubmitDto} sourceSubmitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSourceData: async (sourceSubmitDto: SourceSubmitDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceSubmitDto' is not null or undefined
            assertParamExists('submitSourceData', 'sourceSubmitDto', sourceSubmitDto)
            const localVarPath = `/approval/submit/source`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourceSubmitDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApprovalControllerApi - functional programming interface
 * @export
 */
export const ApprovalControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApprovalControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all sources submitted by the current user.
         * @summary USER. Get my sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMySources(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Source>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMySources(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApprovalControllerApi.getMySources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all problems submitted for the source.
         * @summary Either USER with it\'s problems, or ADMIN, or PUBLIC && source.reviewStatus === ReviewStatus.APPROVED. Get problems by source
         * @param {string} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProblemsBySource(sourceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProblemDisplayViewDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProblemsBySource(sourceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApprovalControllerApi.getProblemsBySource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Doesn\'t work from swagger... responds with 415. Submit problem data with images for approval. Returns the ID of the created problem.
         * @summary USER. Submit problem data with images
         * @param {string} sourceId 
         * @param {ProblemSubmitDto} problem 
         * @param {File} [problemImageFile] 
         * @param {File} [answerImageFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitProblem1(sourceId: string, problem: ProblemSubmitDto, problemImageFile?: File, answerImageFile?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitProblem1(sourceId, problem, problemImageFile, answerImageFile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApprovalControllerApi.submitProblem1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submit source data for approval. Returns the ID of the created source.
         * @summary USER. Submit source data
         * @param {SourceSubmitDto} sourceSubmitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitSourceData(sourceSubmitDto: SourceSubmitDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitSourceData(sourceSubmitDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApprovalControllerApi.submitSourceData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApprovalControllerApi - factory interface
 * @export
 */
export const ApprovalControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApprovalControllerApiFp(configuration)
    return {
        /**
         * Get all sources submitted by the current user.
         * @summary USER. Get my sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMySources(options?: any): AxiosPromise<Array<Source>> {
            return localVarFp.getMySources(options).then((request) => request(axios, basePath));
        },
        /**
         * Get all problems submitted for the source.
         * @summary Either USER with it\'s problems, or ADMIN, or PUBLIC && source.reviewStatus === ReviewStatus.APPROVED. Get problems by source
         * @param {string} sourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProblemsBySource(sourceId: string, options?: any): AxiosPromise<Array<ProblemDisplayViewDto>> {
            return localVarFp.getProblemsBySource(sourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Doesn\'t work from swagger... responds with 415. Submit problem data with images for approval. Returns the ID of the created problem.
         * @summary USER. Submit problem data with images
         * @param {string} sourceId 
         * @param {ProblemSubmitDto} problem 
         * @param {File} [problemImageFile] 
         * @param {File} [answerImageFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitProblem1(sourceId: string, problem: ProblemSubmitDto, problemImageFile?: File, answerImageFile?: File, options?: any): AxiosPromise<IdDto> {
            return localVarFp.submitProblem1(sourceId, problem, problemImageFile, answerImageFile, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit source data for approval. Returns the ID of the created source.
         * @summary USER. Submit source data
         * @param {SourceSubmitDto} sourceSubmitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSourceData(sourceSubmitDto: SourceSubmitDto, options?: any): AxiosPromise<IdDto> {
            return localVarFp.submitSourceData(sourceSubmitDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApprovalControllerApi - object-oriented interface
 * @export
 * @class ApprovalControllerApi
 * @extends {BaseAPI}
 */
export class ApprovalControllerApi extends BaseAPI {
    /**
     * Get all sources submitted by the current user.
     * @summary USER. Get my sources
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalControllerApi
     */
    public getMySources(options?: RawAxiosRequestConfig) {
        return ApprovalControllerApiFp(this.configuration).getMySources(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all problems submitted for the source.
     * @summary Either USER with it\'s problems, or ADMIN, or PUBLIC && source.reviewStatus === ReviewStatus.APPROVED. Get problems by source
     * @param {string} sourceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalControllerApi
     */
    public getProblemsBySource(sourceId: string, options?: RawAxiosRequestConfig) {
        return ApprovalControllerApiFp(this.configuration).getProblemsBySource(sourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Doesn\'t work from swagger... responds with 415. Submit problem data with images for approval. Returns the ID of the created problem.
     * @summary USER. Submit problem data with images
     * @param {string} sourceId 
     * @param {ProblemSubmitDto} problem 
     * @param {File} [problemImageFile] 
     * @param {File} [answerImageFile] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalControllerApi
     */
    public submitProblem1(sourceId: string, problem: ProblemSubmitDto, problemImageFile?: File, answerImageFile?: File, options?: RawAxiosRequestConfig) {
        return ApprovalControllerApiFp(this.configuration).submitProblem1(sourceId, problem, problemImageFile, answerImageFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit source data for approval. Returns the ID of the created source.
     * @summary USER. Submit source data
     * @param {SourceSubmitDto} sourceSubmitDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApprovalControllerApi
     */
    public submitSourceData(sourceSubmitDto: SourceSubmitDto, options?: RawAxiosRequestConfig) {
        return ApprovalControllerApiFp(this.configuration).submitSourceData(sourceSubmitDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CategoryControllerApi - axios parameter creator
 * @export
 */
export const CategoryControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory: async (categoryPostDto: CategoryPostDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryPostDto' is not null or undefined
            assertParamExists('createCategory', 'categoryPostDto', categoryPostDto)
            const localVarPath = `/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoryPostDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCategory', 'id', id)
            const localVarPath = `/category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCategories: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCategoryById', 'id', id)
            const localVarPath = `/category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory1: async (id: string, categoryPostDto: CategoryPostDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCategory1', 'id', id)
            // verify required parameter 'categoryPostDto' is not null or undefined
            assertParamExists('updateCategory1', 'categoryPostDto', categoryPostDto)
            const localVarPath = `/category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoryPostDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoryControllerApi - functional programming interface
 * @export
 */
export const CategoryControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoryControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCategory(categoryPostDto: CategoryPostDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCategory(categoryPostDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerApi.createCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCategory(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCategory(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerApi.deleteCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCategories(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Category>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCategories(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerApi.getAllCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategoryById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategoryById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerApi.getCategoryById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCategory1(id: string, categoryPostDto: CategoryPostDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCategory1(id, categoryPostDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerApi.updateCategory1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CategoryControllerApi - factory interface
 * @export
 */
export const CategoryControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoryControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory(categoryPostDto: CategoryPostDto, options?: any): AxiosPromise<Category> {
            return localVarFp.createCategory(categoryPostDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCategory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCategories(options?: any): AxiosPromise<Array<Category>> {
            return localVarFp.getAllCategories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryById(id: string, options?: any): AxiosPromise<Category> {
            return localVarFp.getCategoryById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory1(id: string, categoryPostDto: CategoryPostDto, options?: any): AxiosPromise<Category> {
            return localVarFp.updateCategory1(id, categoryPostDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoryControllerApi - object-oriented interface
 * @export
 * @class CategoryControllerApi
 * @extends {BaseAPI}
 */
export class CategoryControllerApi extends BaseAPI {
    /**
     * 
     * @param {CategoryPostDto} categoryPostDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public createCategory(categoryPostDto: CategoryPostDto, options?: RawAxiosRequestConfig) {
        return CategoryControllerApiFp(this.configuration).createCategory(categoryPostDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public deleteCategory(id: string, options?: RawAxiosRequestConfig) {
        return CategoryControllerApiFp(this.configuration).deleteCategory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public getAllCategories(options?: RawAxiosRequestConfig) {
        return CategoryControllerApiFp(this.configuration).getAllCategories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public getCategoryById(id: string, options?: RawAxiosRequestConfig) {
        return CategoryControllerApiFp(this.configuration).getCategoryById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {CategoryPostDto} categoryPostDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerApi
     */
    public updateCategory1(id: string, categoryPostDto: CategoryPostDto, options?: RawAxiosRequestConfig) {
        return CategoryControllerApiFp(this.configuration).updateCategory1(id, categoryPostDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CategoryControllerOldApi - axios parameter creator
 * @export
 */
export const CategoryControllerOldApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary ADMIN
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveCategory: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('approveCategory', 'id', id)
            const localVarPath = `/categoryOld/{id}/approve`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary USER
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUnderReviewCategory: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUnderReviewCategory', 'id', id)
            const localVarPath = `/categoryOld/underReview/{id}/cascade`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary PUBLIC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPublicCategories: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/categoryOld`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary USER
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyPublicCategories: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/categoryOld/myPublic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary USER
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyUnderReviewCategories: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/categoryOld/myUnderReview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary PUBLIC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicCategoriesCount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/categoryOld/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary PUBLIC
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicCategory: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPublicCategory', 'id', id)
            const localVarPath = `/categoryOld/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ADMIN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmittedCategories: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/categoryOld/underReview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ADMIN
         * @param {string} id 
         * @param {RejectMsgDto} rejectMsgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectCategory: async (id: string, rejectMsgDto: RejectMsgDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rejectCategory', 'id', id)
            // verify required parameter 'rejectMsgDto' is not null or undefined
            assertParamExists('rejectCategory', 'rejectMsgDto', rejectMsgDto)
            const localVarPath = `/categoryOld/{id}/reject`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rejectMsgDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary USER
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitCategory: async (categoryPostDto: CategoryPostDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryPostDto' is not null or undefined
            assertParamExists('submitCategory', 'categoryPostDto', categoryPostDto)
            const localVarPath = `/categoryOld/submit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoryPostDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary USER
         * @param {string} id 
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory: async (id: string, categoryPostDto: CategoryPostDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCategory', 'id', id)
            // verify required parameter 'categoryPostDto' is not null or undefined
            assertParamExists('updateCategory', 'categoryPostDto', categoryPostDto)
            const localVarPath = `/categoryOld/{id}/fixMyUnderReview`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoryPostDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoryControllerOldApi - functional programming interface
 * @export
 */
export const CategoryControllerOldApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoryControllerOldApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary ADMIN
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveCategory(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveCategory(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerOldApi.approveCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary USER
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUnderReviewCategory(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUnderReviewCategory(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerOldApi.deleteUnderReviewCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary PUBLIC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPublicCategories(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Category>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPublicCategories(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerOldApi.getAllPublicCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary USER
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyPublicCategories(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Category>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyPublicCategories(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerOldApi.getMyPublicCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary USER
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyUnderReviewCategories(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UnderReviewCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyUnderReviewCategories(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerOldApi.getMyUnderReviewCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary PUBLIC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicCategoriesCount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicCategoriesCount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerOldApi.getPublicCategoriesCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary PUBLIC
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicCategory(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicCategory(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerOldApi.getPublicCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary ADMIN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubmittedCategories(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UnderReviewCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubmittedCategories(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerOldApi.getSubmittedCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary ADMIN
         * @param {string} id 
         * @param {RejectMsgDto} rejectMsgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectCategory(id: string, rejectMsgDto: RejectMsgDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnderReviewCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectCategory(id, rejectMsgDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerOldApi.rejectCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary USER
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitCategory(categoryPostDto: CategoryPostDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnderReviewCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitCategory(categoryPostDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerOldApi.submitCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary USER
         * @param {string} id 
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCategory(id: string, categoryPostDto: CategoryPostDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnderReviewCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCategory(id, categoryPostDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryControllerOldApi.updateCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CategoryControllerOldApi - factory interface
 * @export
 */
export const CategoryControllerOldApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoryControllerOldApiFp(configuration)
    return {
        /**
         * 
         * @summary ADMIN
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveCategory(id: string, options?: any): AxiosPromise<Category> {
            return localVarFp.approveCategory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary USER
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUnderReviewCategory(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUnderReviewCategory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary PUBLIC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPublicCategories(options?: any): AxiosPromise<Array<Category>> {
            return localVarFp.getAllPublicCategories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary USER
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyPublicCategories(options?: any): AxiosPromise<Array<Category>> {
            return localVarFp.getMyPublicCategories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary USER
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyUnderReviewCategories(options?: any): AxiosPromise<Array<UnderReviewCategory>> {
            return localVarFp.getMyUnderReviewCategories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary PUBLIC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicCategoriesCount(options?: any): AxiosPromise<CountDto> {
            return localVarFp.getPublicCategoriesCount(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary PUBLIC
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicCategory(id: string, options?: any): AxiosPromise<Category> {
            return localVarFp.getPublicCategory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ADMIN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmittedCategories(options?: any): AxiosPromise<Array<UnderReviewCategory>> {
            return localVarFp.getSubmittedCategories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ADMIN
         * @param {string} id 
         * @param {RejectMsgDto} rejectMsgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectCategory(id: string, rejectMsgDto: RejectMsgDto, options?: any): AxiosPromise<UnderReviewCategory> {
            return localVarFp.rejectCategory(id, rejectMsgDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary USER
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitCategory(categoryPostDto: CategoryPostDto, options?: any): AxiosPromise<UnderReviewCategory> {
            return localVarFp.submitCategory(categoryPostDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary USER
         * @param {string} id 
         * @param {CategoryPostDto} categoryPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory(id: string, categoryPostDto: CategoryPostDto, options?: any): AxiosPromise<UnderReviewCategory> {
            return localVarFp.updateCategory(id, categoryPostDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoryControllerOldApi - object-oriented interface
 * @export
 * @class CategoryControllerOldApi
 * @extends {BaseAPI}
 */
export class CategoryControllerOldApi extends BaseAPI {
    /**
     * 
     * @summary ADMIN
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerOldApi
     */
    public approveCategory(id: string, options?: RawAxiosRequestConfig) {
        return CategoryControllerOldApiFp(this.configuration).approveCategory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary USER
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerOldApi
     */
    public deleteUnderReviewCategory(id: string, options?: RawAxiosRequestConfig) {
        return CategoryControllerOldApiFp(this.configuration).deleteUnderReviewCategory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary PUBLIC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerOldApi
     */
    public getAllPublicCategories(options?: RawAxiosRequestConfig) {
        return CategoryControllerOldApiFp(this.configuration).getAllPublicCategories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary USER
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerOldApi
     */
    public getMyPublicCategories(options?: RawAxiosRequestConfig) {
        return CategoryControllerOldApiFp(this.configuration).getMyPublicCategories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary USER
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerOldApi
     */
    public getMyUnderReviewCategories(options?: RawAxiosRequestConfig) {
        return CategoryControllerOldApiFp(this.configuration).getMyUnderReviewCategories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary PUBLIC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerOldApi
     */
    public getPublicCategoriesCount(options?: RawAxiosRequestConfig) {
        return CategoryControllerOldApiFp(this.configuration).getPublicCategoriesCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary PUBLIC
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerOldApi
     */
    public getPublicCategory(id: string, options?: RawAxiosRequestConfig) {
        return CategoryControllerOldApiFp(this.configuration).getPublicCategory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ADMIN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerOldApi
     */
    public getSubmittedCategories(options?: RawAxiosRequestConfig) {
        return CategoryControllerOldApiFp(this.configuration).getSubmittedCategories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ADMIN
     * @param {string} id 
     * @param {RejectMsgDto} rejectMsgDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerOldApi
     */
    public rejectCategory(id: string, rejectMsgDto: RejectMsgDto, options?: RawAxiosRequestConfig) {
        return CategoryControllerOldApiFp(this.configuration).rejectCategory(id, rejectMsgDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary USER
     * @param {CategoryPostDto} categoryPostDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerOldApi
     */
    public submitCategory(categoryPostDto: CategoryPostDto, options?: RawAxiosRequestConfig) {
        return CategoryControllerOldApiFp(this.configuration).submitCategory(categoryPostDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary USER
     * @param {string} id 
     * @param {CategoryPostDto} categoryPostDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryControllerOldApi
     */
    public updateCategory(id: string, categoryPostDto: CategoryPostDto, options?: RawAxiosRequestConfig) {
        return CategoryControllerOldApiFp(this.configuration).updateCategory(id, categoryPostDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProblemControllerApi - axios parameter creator
 * @export
 */
export const ProblemControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ProblemPostDto} problemPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProblem: async (problemPostDto: ProblemPostDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'problemPostDto' is not null or undefined
            assertParamExists('createProblem', 'problemPostDto', problemPostDto)
            const localVarPath = `/problem`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(problemPostDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProblem: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProblem', 'id', id)
            const localVarPath = `/problem/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProblems: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/problem`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProblemById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProblemById', 'id', id)
            const localVarPath = `/problem/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ProblemPostDto} problemPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProblem: async (id: string, problemPostDto: ProblemPostDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProblem', 'id', id)
            // verify required parameter 'problemPostDto' is not null or undefined
            assertParamExists('updateProblem', 'problemPostDto', problemPostDto)
            const localVarPath = `/problem/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(problemPostDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProblemControllerApi - functional programming interface
 * @export
 */
export const ProblemControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProblemControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ProblemPostDto} problemPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProblem(problemPostDto: ProblemPostDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Problem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProblem(problemPostDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProblemControllerApi.createProblem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProblem(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProblem(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProblemControllerApi.deleteProblem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllProblems(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Problem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllProblems(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProblemControllerApi.getAllProblems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProblemById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Problem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProblemById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProblemControllerApi.getProblemById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {ProblemPostDto} problemPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProblem(id: string, problemPostDto: ProblemPostDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Problem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProblem(id, problemPostDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProblemControllerApi.updateProblem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProblemControllerApi - factory interface
 * @export
 */
export const ProblemControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProblemControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {ProblemPostDto} problemPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProblem(problemPostDto: ProblemPostDto, options?: any): AxiosPromise<Problem> {
            return localVarFp.createProblem(problemPostDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProblem(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProblem(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProblems(options?: any): AxiosPromise<Array<Problem>> {
            return localVarFp.getAllProblems(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProblemById(id: string, options?: any): AxiosPromise<Problem> {
            return localVarFp.getProblemById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {ProblemPostDto} problemPostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProblem(id: string, problemPostDto: ProblemPostDto, options?: any): AxiosPromise<Problem> {
            return localVarFp.updateProblem(id, problemPostDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProblemControllerApi - object-oriented interface
 * @export
 * @class ProblemControllerApi
 * @extends {BaseAPI}
 */
export class ProblemControllerApi extends BaseAPI {
    /**
     * 
     * @param {ProblemPostDto} problemPostDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProblemControllerApi
     */
    public createProblem(problemPostDto: ProblemPostDto, options?: RawAxiosRequestConfig) {
        return ProblemControllerApiFp(this.configuration).createProblem(problemPostDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProblemControllerApi
     */
    public deleteProblem(id: string, options?: RawAxiosRequestConfig) {
        return ProblemControllerApiFp(this.configuration).deleteProblem(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProblemControllerApi
     */
    public getAllProblems(options?: RawAxiosRequestConfig) {
        return ProblemControllerApiFp(this.configuration).getAllProblems(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProblemControllerApi
     */
    public getProblemById(id: string, options?: RawAxiosRequestConfig) {
        return ProblemControllerApiFp(this.configuration).getProblemById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {ProblemPostDto} problemPostDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProblemControllerApi
     */
    public updateProblem(id: string, problemPostDto: ProblemPostDto, options?: RawAxiosRequestConfig) {
        return ProblemControllerApiFp(this.configuration).updateProblem(id, problemPostDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProblemControllerOldApi - axios parameter creator
 * @export
 */
export const ProblemControllerOldApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary ADMIN
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveProblem: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('approveProblem', 'id', id)
            const localVarPath = `/problemOld/{id}/approve`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary USER
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUnderReviewProblem: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUnderReviewProblem', 'id', id)
            const localVarPath = `/problemOld/underReview/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary USER
         * @param {string} id 
         * @param {FixMyUnderReviewProblemRequest} [fixMyUnderReviewProblemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fixMyUnderReviewProblem: async (id: string, fixMyUnderReviewProblemRequest?: FixMyUnderReviewProblemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fixMyUnderReviewProblem', 'id', id)
            const localVarPath = `/problemOld/{id}/fixMyUnderReview`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fixMyUnderReviewProblemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary USER
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyAllSubmittedProblems: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/problemOld/myAllSubmitted`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary PUBLIC
         * @param {string} skfCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicProblem: async (skfCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'skfCode' is not null or undefined
            assertParamExists('getPublicProblem', 'skfCode', skfCode)
            const localVarPath = `/problemOld/{skfCode}`
                .replace(`{${"skfCode"}}`, encodeURIComponent(String(skfCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary PUBLIC
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicProblemsByCategory: async (categoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getPublicProblemsByCategory', 'categoryId', categoryId)
            const localVarPath = `/problemOld/byCategory/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary PUBLIC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicProblemsCount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/problemOld/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will fetch a list of problems under review by doesn\'t matter - under review or approved - category ID.
         * @summary ADMIN
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnderReviewProblemsByArbitraryCategory: async (categoryId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getUnderReviewProblemsByArbitraryCategory', 'categoryId', categoryId)
            const localVarPath = `/problemOld/underReview/byArbitraryCategory/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ADMIN
         * @param {string} id 
         * @param {RejectMsgDto} rejectMsgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectProblem: async (id: string, rejectMsgDto: RejectMsgDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rejectProblem', 'id', id)
            // verify required parameter 'rejectMsgDto' is not null or undefined
            assertParamExists('rejectProblem', 'rejectMsgDto', rejectMsgDto)
            const localVarPath = `/problemOld/{id}/reject`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rejectMsgDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *              **Logic**:             - If `problem.problemImageUrl` is a URL and `problemImageFile` is null, return `problemImagePath = problem.problemImage`.             - If `problem.problemImageUrl` is \"\" and `problemImageFile` is provided, upload the file and return `problemImagePath = \"problems/SKF-...\"`.             - If `problem.problemImageUrl` is \"\" and `problemImageFile` is null, return `problemImagePath = \"\"`.         
         * @summary USER. Careful! Complex file and text upload logic AND not easily testable file upload!
         * @param {ProblemPostDtoOld} problem 
         * @param {File} [problemImageFile] 
         * @param {File} [answerImageFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitProblem: async (problem: ProblemPostDtoOld, problemImageFile?: File, answerImageFile?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'problem' is not null or undefined
            assertParamExists('submitProblem', 'problem', problem)
            const localVarPath = `/problemOld/submit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (problem !== undefined) { 
                localVarFormParams.append('problem', new Blob([JSON.stringify(problem)], { type: "application/json", }));
            }
    
            if (problemImageFile !== undefined) { 
                localVarFormParams.append('problemImageFile', problemImageFile as any);
            }
    
            if (answerImageFile !== undefined) { 
                localVarFormParams.append('answerImageFile', answerImageFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProblemControllerOldApi - functional programming interface
 * @export
 */
export const ProblemControllerOldApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProblemControllerOldApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary ADMIN
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveProblem(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Problem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveProblem(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProblemControllerOldApi.approveProblem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary USER
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUnderReviewProblem(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUnderReviewProblem(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProblemControllerOldApi.deleteUnderReviewProblem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary USER
         * @param {string} id 
         * @param {FixMyUnderReviewProblemRequest} [fixMyUnderReviewProblemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fixMyUnderReviewProblem(id: string, fixMyUnderReviewProblemRequest?: FixMyUnderReviewProblemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnderReviewProblem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fixMyUnderReviewProblem(id, fixMyUnderReviewProblemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProblemControllerOldApi.fixMyUnderReviewProblem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary USER
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyAllSubmittedProblems(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProblemsForAuthor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyAllSubmittedProblems(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProblemControllerOldApi.getMyAllSubmittedProblems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary PUBLIC
         * @param {string} skfCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicProblem(skfCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProblemDisplayViewDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicProblem(skfCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProblemControllerOldApi.getPublicProblem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary PUBLIC
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicProblemsByCategory(categoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProblemDisplayViewDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicProblemsByCategory(categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProblemControllerOldApi.getPublicProblemsByCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary PUBLIC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicProblemsCount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicProblemsCount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProblemControllerOldApi.getPublicProblemsCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This will fetch a list of problems under review by doesn\'t matter - under review or approved - category ID.
         * @summary ADMIN
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnderReviewProblemsByArbitraryCategory(categoryId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UnderReviewProblemDisplayViewDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnderReviewProblemsByArbitraryCategory(categoryId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProblemControllerOldApi.getUnderReviewProblemsByArbitraryCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary ADMIN
         * @param {string} id 
         * @param {RejectMsgDto} rejectMsgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectProblem(id: string, rejectMsgDto: RejectMsgDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnderReviewProblem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectProblem(id, rejectMsgDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProblemControllerOldApi.rejectProblem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *              **Logic**:             - If `problem.problemImageUrl` is a URL and `problemImageFile` is null, return `problemImagePath = problem.problemImage`.             - If `problem.problemImageUrl` is \"\" and `problemImageFile` is provided, upload the file and return `problemImagePath = \"problems/SKF-...\"`.             - If `problem.problemImageUrl` is \"\" and `problemImageFile` is null, return `problemImagePath = \"\"`.         
         * @summary USER. Careful! Complex file and text upload logic AND not easily testable file upload!
         * @param {ProblemPostDtoOld} problem 
         * @param {File} [problemImageFile] 
         * @param {File} [answerImageFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitProblem(problem: ProblemPostDtoOld, problemImageFile?: File, answerImageFile?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnderReviewProblem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitProblem(problem, problemImageFile, answerImageFile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProblemControllerOldApi.submitProblem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProblemControllerOldApi - factory interface
 * @export
 */
export const ProblemControllerOldApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProblemControllerOldApiFp(configuration)
    return {
        /**
         * 
         * @summary ADMIN
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveProblem(id: string, options?: any): AxiosPromise<Problem> {
            return localVarFp.approveProblem(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary USER
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUnderReviewProblem(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUnderReviewProblem(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary USER
         * @param {string} id 
         * @param {FixMyUnderReviewProblemRequest} [fixMyUnderReviewProblemRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fixMyUnderReviewProblem(id: string, fixMyUnderReviewProblemRequest?: FixMyUnderReviewProblemRequest, options?: any): AxiosPromise<UnderReviewProblem> {
            return localVarFp.fixMyUnderReviewProblem(id, fixMyUnderReviewProblemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary USER
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyAllSubmittedProblems(options?: any): AxiosPromise<ProblemsForAuthor> {
            return localVarFp.getMyAllSubmittedProblems(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary PUBLIC
         * @param {string} skfCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicProblem(skfCode: string, options?: any): AxiosPromise<ProblemDisplayViewDto> {
            return localVarFp.getPublicProblem(skfCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary PUBLIC
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicProblemsByCategory(categoryId: string, options?: any): AxiosPromise<Array<ProblemDisplayViewDto>> {
            return localVarFp.getPublicProblemsByCategory(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary PUBLIC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicProblemsCount(options?: any): AxiosPromise<CountDto> {
            return localVarFp.getPublicProblemsCount(options).then((request) => request(axios, basePath));
        },
        /**
         * This will fetch a list of problems under review by doesn\'t matter - under review or approved - category ID.
         * @summary ADMIN
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnderReviewProblemsByArbitraryCategory(categoryId: string, options?: any): AxiosPromise<Array<UnderReviewProblemDisplayViewDto>> {
            return localVarFp.getUnderReviewProblemsByArbitraryCategory(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ADMIN
         * @param {string} id 
         * @param {RejectMsgDto} rejectMsgDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectProblem(id: string, rejectMsgDto: RejectMsgDto, options?: any): AxiosPromise<UnderReviewProblem> {
            return localVarFp.rejectProblem(id, rejectMsgDto, options).then((request) => request(axios, basePath));
        },
        /**
         *              **Logic**:             - If `problem.problemImageUrl` is a URL and `problemImageFile` is null, return `problemImagePath = problem.problemImage`.             - If `problem.problemImageUrl` is \"\" and `problemImageFile` is provided, upload the file and return `problemImagePath = \"problems/SKF-...\"`.             - If `problem.problemImageUrl` is \"\" and `problemImageFile` is null, return `problemImagePath = \"\"`.         
         * @summary USER. Careful! Complex file and text upload logic AND not easily testable file upload!
         * @param {ProblemPostDtoOld} problem 
         * @param {File} [problemImageFile] 
         * @param {File} [answerImageFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitProblem(problem: ProblemPostDtoOld, problemImageFile?: File, answerImageFile?: File, options?: any): AxiosPromise<UnderReviewProblem> {
            return localVarFp.submitProblem(problem, problemImageFile, answerImageFile, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProblemControllerOldApi - object-oriented interface
 * @export
 * @class ProblemControllerOldApi
 * @extends {BaseAPI}
 */
export class ProblemControllerOldApi extends BaseAPI {
    /**
     * 
     * @summary ADMIN
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProblemControllerOldApi
     */
    public approveProblem(id: string, options?: RawAxiosRequestConfig) {
        return ProblemControllerOldApiFp(this.configuration).approveProblem(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary USER
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProblemControllerOldApi
     */
    public deleteUnderReviewProblem(id: string, options?: RawAxiosRequestConfig) {
        return ProblemControllerOldApiFp(this.configuration).deleteUnderReviewProblem(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary USER
     * @param {string} id 
     * @param {FixMyUnderReviewProblemRequest} [fixMyUnderReviewProblemRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProblemControllerOldApi
     */
    public fixMyUnderReviewProblem(id: string, fixMyUnderReviewProblemRequest?: FixMyUnderReviewProblemRequest, options?: RawAxiosRequestConfig) {
        return ProblemControllerOldApiFp(this.configuration).fixMyUnderReviewProblem(id, fixMyUnderReviewProblemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary USER
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProblemControllerOldApi
     */
    public getMyAllSubmittedProblems(options?: RawAxiosRequestConfig) {
        return ProblemControllerOldApiFp(this.configuration).getMyAllSubmittedProblems(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary PUBLIC
     * @param {string} skfCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProblemControllerOldApi
     */
    public getPublicProblem(skfCode: string, options?: RawAxiosRequestConfig) {
        return ProblemControllerOldApiFp(this.configuration).getPublicProblem(skfCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary PUBLIC
     * @param {string} categoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProblemControllerOldApi
     */
    public getPublicProblemsByCategory(categoryId: string, options?: RawAxiosRequestConfig) {
        return ProblemControllerOldApiFp(this.configuration).getPublicProblemsByCategory(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary PUBLIC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProblemControllerOldApi
     */
    public getPublicProblemsCount(options?: RawAxiosRequestConfig) {
        return ProblemControllerOldApiFp(this.configuration).getPublicProblemsCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will fetch a list of problems under review by doesn\'t matter - under review or approved - category ID.
     * @summary ADMIN
     * @param {string} categoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProblemControllerOldApi
     */
    public getUnderReviewProblemsByArbitraryCategory(categoryId: string, options?: RawAxiosRequestConfig) {
        return ProblemControllerOldApiFp(this.configuration).getUnderReviewProblemsByArbitraryCategory(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ADMIN
     * @param {string} id 
     * @param {RejectMsgDto} rejectMsgDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProblemControllerOldApi
     */
    public rejectProblem(id: string, rejectMsgDto: RejectMsgDto, options?: RawAxiosRequestConfig) {
        return ProblemControllerOldApiFp(this.configuration).rejectProblem(id, rejectMsgDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *              **Logic**:             - If `problem.problemImageUrl` is a URL and `problemImageFile` is null, return `problemImagePath = problem.problemImage`.             - If `problem.problemImageUrl` is \"\" and `problemImageFile` is provided, upload the file and return `problemImagePath = \"problems/SKF-...\"`.             - If `problem.problemImageUrl` is \"\" and `problemImageFile` is null, return `problemImagePath = \"\"`.         
     * @summary USER. Careful! Complex file and text upload logic AND not easily testable file upload!
     * @param {ProblemPostDtoOld} problem 
     * @param {File} [problemImageFile] 
     * @param {File} [answerImageFile] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProblemControllerOldApi
     */
    public submitProblem(problem: ProblemPostDtoOld, problemImageFile?: File, answerImageFile?: File, options?: RawAxiosRequestConfig) {
        return ProblemControllerOldApiFp(this.configuration).submitProblem(problem, problemImageFile, answerImageFile, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SourceControllerApi - axios parameter creator
 * @export
 */
export const SourceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SourcePostDto} sourcePostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSource: async (sourcePostDto: SourcePostDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourcePostDto' is not null or undefined
            assertParamExists('createSource', 'sourcePostDto', sourcePostDto)
            const localVarPath = `/source`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourcePostDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSource', 'id', id)
            const localVarPath = `/source/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSources: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/source`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourceById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSourceById', 'id', id)
            const localVarPath = `/source/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {SourcePostDto} sourcePostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSource: async (id: string, sourcePostDto: SourcePostDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSource', 'id', id)
            // verify required parameter 'sourcePostDto' is not null or undefined
            assertParamExists('updateSource', 'sourcePostDto', sourcePostDto)
            const localVarPath = `/source/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sourcePostDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SourceControllerApi - functional programming interface
 * @export
 */
export const SourceControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SourceControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {SourcePostDto} sourcePostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSource(sourcePostDto: SourcePostDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSource(sourcePostDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourceControllerApi.createSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSource(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSource(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourceControllerApi.deleteSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSources(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Source>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllSources(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourceControllerApi.getAllSources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSourceById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSourceById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourceControllerApi.getSourceById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {SourcePostDto} sourcePostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSource(id: string, sourcePostDto: SourcePostDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Source>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSource(id, sourcePostDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SourceControllerApi.updateSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SourceControllerApi - factory interface
 * @export
 */
export const SourceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SourceControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {SourcePostDto} sourcePostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSource(sourcePostDto: SourcePostDto, options?: any): AxiosPromise<Source> {
            return localVarFp.createSource(sourcePostDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSource(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSource(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSources(options?: any): AxiosPromise<Array<Source>> {
            return localVarFp.getAllSources(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSourceById(id: string, options?: any): AxiosPromise<Source> {
            return localVarFp.getSourceById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {SourcePostDto} sourcePostDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSource(id: string, sourcePostDto: SourcePostDto, options?: any): AxiosPromise<Source> {
            return localVarFp.updateSource(id, sourcePostDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SourceControllerApi - object-oriented interface
 * @export
 * @class SourceControllerApi
 * @extends {BaseAPI}
 */
export class SourceControllerApi extends BaseAPI {
    /**
     * 
     * @param {SourcePostDto} sourcePostDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceControllerApi
     */
    public createSource(sourcePostDto: SourcePostDto, options?: RawAxiosRequestConfig) {
        return SourceControllerApiFp(this.configuration).createSource(sourcePostDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceControllerApi
     */
    public deleteSource(id: string, options?: RawAxiosRequestConfig) {
        return SourceControllerApiFp(this.configuration).deleteSource(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceControllerApi
     */
    public getAllSources(options?: RawAxiosRequestConfig) {
        return SourceControllerApiFp(this.configuration).getAllSources(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceControllerApi
     */
    public getSourceById(id: string, options?: RawAxiosRequestConfig) {
        return SourceControllerApiFp(this.configuration).getSourceById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {SourcePostDto} sourcePostDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SourceControllerApi
     */
    public updateSource(id: string, sourcePostDto: SourcePostDto, options?: RawAxiosRequestConfig) {
        return SourceControllerApiFp(this.configuration).updateSource(id, sourcePostDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TestControllerApi - axios parameter creator
 * @export
 */
export const TestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/test/getUserId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestControllerApi - functional programming interface
 * @export
 */
export const TestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async test(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.test(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestControllerApi.test']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TestControllerApi - factory interface
 * @export
 */
export const TestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test(options?: any): AxiosPromise<string> {
            return localVarFp.test(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestControllerApi - object-oriented interface
 * @export
 * @class TestControllerApi
 * @extends {BaseAPI}
 */
export class TestControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestControllerApi
     */
    public test(options?: RawAxiosRequestConfig) {
        return TestControllerApiFp(this.configuration).test(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserControllerApi - axios parameter creator
 * @export
 */
export const UserControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary PUBLIC
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBio: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getBio', 'username', username)
            const localVarPath = `/user/bio/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary USER
         * @param {UserBioDto} userBioDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBio: async (userBioDto: UserBioDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userBioDto' is not null or undefined
            assertParamExists('updateBio', 'userBioDto', userBioDto)
            const localVarPath = `/user/bio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userBioDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserControllerApi - functional programming interface
 * @export
 */
export const UserControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary PUBLIC
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBio(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserBioDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBio(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.getBio']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary USER
         * @param {UserBioDto} userBioDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBio(userBioDto: UserBioDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBio(userBioDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.updateBio']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserControllerApi - factory interface
 * @export
 */
export const UserControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary PUBLIC
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBio(username: string, options?: any): AxiosPromise<UserBioDto> {
            return localVarFp.getBio(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary USER
         * @param {UserBioDto} userBioDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBio(userBioDto: UserBioDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateBio(userBioDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserControllerApi - object-oriented interface
 * @export
 * @class UserControllerApi
 * @extends {BaseAPI}
 */
export class UserControllerApi extends BaseAPI {
    /**
     * 
     * @summary PUBLIC
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getBio(username: string, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getBio(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary USER
     * @param {UserBioDto} userBioDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public updateBio(userBioDto: UserBioDto, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).updateBio(userBioDto, options).then((request) => request(this.axios, this.basePath));
    }
}



