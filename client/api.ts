/* tslint:disable */
/* eslint-disable */
/**
 * Skafis užduočių bankas API
 * This is bankas.skafis.lt API.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
	DUMMY_BASE_URL,
	assertParamExists,
	setApiKeyToObject,
	setBasicAuthToObject,
	setBearerAuthToObject,
	setOAuthToObject,
	setSearchParams,
	serializeDataIfNeeded,
	toPathString,
	createRequestFunction
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 *
 * @export
 * @interface CategoryPostDto
 */
export interface CategoryPostDto {
	/**
	 *
	 * @type {string}
	 * @memberof CategoryPostDto
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof CategoryPostDto
	 */
	description: string;
}
/**
 *
 * @export
 * @interface CategoryViewDto
 */
export interface CategoryViewDto {
	/**
	 *
	 * @type {string}
	 * @memberof CategoryViewDto
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof CategoryViewDto
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof CategoryViewDto
	 */
	description: string;
	/**
	 *
	 * @type {string}
	 * @memberof CategoryViewDto
	 */
	createdOn: string;
	/**
	 *
	 * @type {string}
	 * @memberof CategoryViewDto
	 */
	createdBy: string;
}
/**
 *
 * @export
 * @interface CountDto
 */
export interface CountDto {
	/**
	 *
	 * @type {number}
	 * @memberof CountDto
	 */
	count: number;
}
/**
 *
 * @export
 * @interface ProblemDisplayViewDto
 */
export interface ProblemDisplayViewDto {
	/**
	 *
	 * @type {string}
	 * @memberof ProblemDisplayViewDto
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProblemDisplayViewDto
	 */
	problemImageSrc?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProblemDisplayViewDto
	 */
	answerImageSrc?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProblemDisplayViewDto
	 */
	problemText?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProblemDisplayViewDto
	 */
	answerText?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProblemDisplayViewDto
	 */
	categoryId: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProblemDisplayViewDto
	 */
	createdOn: string;
}
/**
 *
 * @export
 * @interface ProblemPostDto
 */
export interface ProblemPostDto {
	/**
	 *
	 * @type {string}
	 * @memberof ProblemPostDto
	 */
	problemImage?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProblemPostDto
	 */
	answerImage?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProblemPostDto
	 */
	problemText?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProblemPostDto
	 */
	answerText?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProblemPostDto
	 */
	categoryId: string;
}
/**
 *
 * @export
 * @interface ProblemViewDto
 */
export interface ProblemViewDto {
	/**
	 *
	 * @type {string}
	 * @memberof ProblemViewDto
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProblemViewDto
	 */
	problemImage?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProblemViewDto
	 */
	answerImage?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProblemViewDto
	 */
	problemText?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProblemViewDto
	 */
	answerText?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProblemViewDto
	 */
	categoryId: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProblemViewDto
	 */
	createdOn: string;
}
/**
 *
 * @export
 * @interface UpdateProblemRequest
 */
export interface UpdateProblemRequest {
	/**
	 *
	 * @type {ProblemPostDto}
	 * @memberof UpdateProblemRequest
	 */
	problem?: ProblemPostDto;
	/**
	 *
	 * @type {File}
	 * @memberof UpdateProblemRequest
	 */
	problemImageFile?: File;
	/**
	 *
	 * @type {File}
	 * @memberof UpdateProblemRequest
	 */
	answerImageFile?: File;
}

/**
 * CategoryControllerApi - axios parameter creator
 * @export
 */
export const CategoryControllerApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @param {CategoryPostDto} categoryPostDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createCategory: async (
			categoryPostDto: CategoryPostDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'categoryPostDto' is not null or undefined
			assertParamExists('createCategory', 'categoryPostDto', categoryPostDto);
			const localVarPath = `/api/categories`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearerAuth required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter['Content-Type'] = 'application/json';

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				categoryPostDto,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteCategory: async (
			id: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('deleteCategory', 'id', id);
			const localVarPath = `/api/categories/{id}/cascade`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearerAuth required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getAllCategories: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
			const localVarPath = `/api/categories`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getCategoriesCount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
			const localVarPath = `/api/categories/count`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getCategory: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('getCategory', 'id', id);
			const localVarPath = `/api/categories/{id}`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 *
		 * @param {string} id
		 * @param {CategoryPostDto} categoryPostDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateCategory: async (
			id: string,
			categoryPostDto: CategoryPostDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('updateCategory', 'id', id);
			// verify required parameter 'categoryPostDto' is not null or undefined
			assertParamExists('updateCategory', 'categoryPostDto', categoryPostDto);
			const localVarPath = `/api/categories/{id}`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearerAuth required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter['Content-Type'] = 'application/json';

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				categoryPostDto,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		}
	};
};

/**
 * CategoryControllerApi - functional programming interface
 * @export
 */
export const CategoryControllerApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = CategoryControllerApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {CategoryPostDto} categoryPostDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async createCategory(
			categoryPostDto: CategoryPostDto,
			options?: RawAxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryViewDto>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.createCategory(
				categoryPostDto,
				options
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap['CategoryControllerApi.createCategory']?.[localVarOperationServerIndex]
					?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async deleteCategory(
			id: string,
			options?: RawAxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCategory(id, options);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap['CategoryControllerApi.deleteCategory']?.[localVarOperationServerIndex]
					?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getAllCategories(
			options?: RawAxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CategoryViewDto>>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCategories(options);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap['CategoryControllerApi.getAllCategories']?.[localVarOperationServerIndex]
					?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getCategoriesCount(
			options?: RawAxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountDto>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getCategoriesCount(options);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap['CategoryControllerApi.getCategoriesCount']?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getCategory(
			id: string,
			options?: RawAxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryViewDto>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getCategory(id, options);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap['CategoryControllerApi.getCategory']?.[localVarOperationServerIndex]
					?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @param {string} id
		 * @param {CategoryPostDto} categoryPostDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async updateCategory(
			id: string,
			categoryPostDto: CategoryPostDto,
			options?: RawAxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryViewDto>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.updateCategory(
				id,
				categoryPostDto,
				options
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap['CategoryControllerApi.updateCategory']?.[localVarOperationServerIndex]
					?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		}
	};
};

/**
 * CategoryControllerApi - factory interface
 * @export
 */
export const CategoryControllerApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = CategoryControllerApiFp(configuration);
	return {
		/**
		 *
		 * @param {CategoryPostDto} categoryPostDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createCategory(categoryPostDto: CategoryPostDto, options?: any): AxiosPromise<CategoryViewDto> {
			return localVarFp
				.createCategory(categoryPostDto, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteCategory(id: string, options?: any): AxiosPromise<void> {
			return localVarFp.deleteCategory(id, options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getAllCategories(options?: any): AxiosPromise<Array<CategoryViewDto>> {
			return localVarFp.getAllCategories(options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getCategoriesCount(options?: any): AxiosPromise<CountDto> {
			return localVarFp.getCategoriesCount(options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getCategory(id: string, options?: any): AxiosPromise<CategoryViewDto> {
			return localVarFp.getCategory(id, options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} id
		 * @param {CategoryPostDto} categoryPostDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateCategory(
			id: string,
			categoryPostDto: CategoryPostDto,
			options?: any
		): AxiosPromise<CategoryViewDto> {
			return localVarFp
				.updateCategory(id, categoryPostDto, options)
				.then((request) => request(axios, basePath));
		}
	};
};

/**
 * CategoryControllerApi - object-oriented interface
 * @export
 * @class CategoryControllerApi
 * @extends {BaseAPI}
 */
export class CategoryControllerApi extends BaseAPI {
	/**
	 *
	 * @param {CategoryPostDto} categoryPostDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CategoryControllerApi
	 */
	public createCategory(categoryPostDto: CategoryPostDto, options?: RawAxiosRequestConfig) {
		return CategoryControllerApiFp(this.configuration)
			.createCategory(categoryPostDto, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} id
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CategoryControllerApi
	 */
	public deleteCategory(id: string, options?: RawAxiosRequestConfig) {
		return CategoryControllerApiFp(this.configuration)
			.deleteCategory(id, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CategoryControllerApi
	 */
	public getAllCategories(options?: RawAxiosRequestConfig) {
		return CategoryControllerApiFp(this.configuration)
			.getAllCategories(options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CategoryControllerApi
	 */
	public getCategoriesCount(options?: RawAxiosRequestConfig) {
		return CategoryControllerApiFp(this.configuration)
			.getCategoriesCount(options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} id
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CategoryControllerApi
	 */
	public getCategory(id: string, options?: RawAxiosRequestConfig) {
		return CategoryControllerApiFp(this.configuration)
			.getCategory(id, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} id
	 * @param {CategoryPostDto} categoryPostDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CategoryControllerApi
	 */
	public updateCategory(
		id: string,
		categoryPostDto: CategoryPostDto,
		options?: RawAxiosRequestConfig
	) {
		return CategoryControllerApiFp(this.configuration)
			.updateCategory(id, categoryPostDto, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * ProblemControllerApi - axios parameter creator
 * @export
 */
export const ProblemControllerApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @param {UpdateProblemRequest} updateProblemRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createProblem: async (
			updateProblemRequest: UpdateProblemRequest,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'updateProblemRequest' is not null or undefined
			assertParamExists('createProblem', 'updateProblemRequest', updateProblemRequest);
			const localVarPath = `/api/problems`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearerAuth required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter['Content-Type'] = 'application/json';

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				updateProblemRequest,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteProblem: async (
			id: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('deleteProblem', 'id', id);
			const localVarPath = `/api/problems/{id}`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearerAuth required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getProblem: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('getProblem', 'id', id);
			const localVarPath = `/api/problems/{id}`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 *
		 * @param {string} categoryId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getProblemsByCategory: async (
			categoryId: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'categoryId' is not null or undefined
			assertParamExists('getProblemsByCategory', 'categoryId', categoryId);
			const localVarPath = `/api/problems/byCategory/{categoryId}`.replace(
				`{${'categoryId'}}`,
				encodeURIComponent(String(categoryId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getProblemsCount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
			const localVarPath = `/api/problems/count`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		},
		/**
		 *
		 * @param {string} id
		 * @param {UpdateProblemRequest} updateProblemRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateProblem: async (
			id: string,
			updateProblemRequest: UpdateProblemRequest,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('updateProblem', 'id', id);
			// verify required parameter 'updateProblemRequest' is not null or undefined
			assertParamExists('updateProblem', 'updateProblemRequest', updateProblemRequest);
			const localVarPath = `/api/problems/{id}`.replace(
				`{${'id'}}`,
				encodeURIComponent(String(id))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearerAuth required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter['Content-Type'] = 'application/json';

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				updateProblemRequest,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		}
	};
};

/**
 * ProblemControllerApi - functional programming interface
 * @export
 */
export const ProblemControllerApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = ProblemControllerApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {UpdateProblemRequest} updateProblemRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async createProblem(
			updateProblemRequest: UpdateProblemRequest,
			options?: RawAxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProblemViewDto>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.createProblem(
				updateProblemRequest,
				options
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap['ProblemControllerApi.createProblem']?.[localVarOperationServerIndex]
					?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async deleteProblem(
			id: string,
			options?: RawAxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProblem(id, options);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap['ProblemControllerApi.deleteProblem']?.[localVarOperationServerIndex]
					?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getProblem(
			id: string,
			options?: RawAxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProblemDisplayViewDto>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getProblem(id, options);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap['ProblemControllerApi.getProblem']?.[localVarOperationServerIndex]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @param {string} categoryId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getProblemsByCategory(
			categoryId: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProblemDisplayViewDto>>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getProblemsByCategory(
				categoryId,
				options
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap['ProblemControllerApi.getProblemsByCategory']?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getProblemsCount(
			options?: RawAxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountDto>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getProblemsCount(options);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap['ProblemControllerApi.getProblemsCount']?.[localVarOperationServerIndex]
					?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @param {string} id
		 * @param {UpdateProblemRequest} updateProblemRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async updateProblem(
			id: string,
			updateProblemRequest: UpdateProblemRequest,
			options?: RawAxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProblemViewDto>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.updateProblem(
				id,
				updateProblemRequest,
				options
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap['ProblemControllerApi.updateProblem']?.[localVarOperationServerIndex]
					?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		}
	};
};

/**
 * ProblemControllerApi - factory interface
 * @export
 */
export const ProblemControllerApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = ProblemControllerApiFp(configuration);
	return {
		/**
		 *
		 * @param {UpdateProblemRequest} updateProblemRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createProblem(
			updateProblemRequest: UpdateProblemRequest,
			options?: any
		): AxiosPromise<ProblemViewDto> {
			return localVarFp
				.createProblem(updateProblemRequest, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteProblem(id: string, options?: any): AxiosPromise<void> {
			return localVarFp.deleteProblem(id, options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getProblem(id: string, options?: any): AxiosPromise<ProblemDisplayViewDto> {
			return localVarFp.getProblem(id, options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} categoryId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getProblemsByCategory(
			categoryId: string,
			options?: any
		): AxiosPromise<Array<ProblemDisplayViewDto>> {
			return localVarFp
				.getProblemsByCategory(categoryId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getProblemsCount(options?: any): AxiosPromise<CountDto> {
			return localVarFp.getProblemsCount(options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} id
		 * @param {UpdateProblemRequest} updateProblemRequest
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateProblem(
			id: string,
			updateProblemRequest: UpdateProblemRequest,
			options?: any
		): AxiosPromise<ProblemViewDto> {
			return localVarFp
				.updateProblem(id, updateProblemRequest, options)
				.then((request) => request(axios, basePath));
		}
	};
};

/**
 * ProblemControllerApi - object-oriented interface
 * @export
 * @class ProblemControllerApi
 * @extends {BaseAPI}
 */
export class ProblemControllerApi extends BaseAPI {
	/**
	 *
	 * @param {UpdateProblemRequest} updateProblemRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProblemControllerApi
	 */
	public createProblem(
		updateProblemRequest: UpdateProblemRequest,
		options?: RawAxiosRequestConfig
	) {
		return ProblemControllerApiFp(this.configuration)
			.createProblem(updateProblemRequest, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} id
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProblemControllerApi
	 */
	public deleteProblem(id: string, options?: RawAxiosRequestConfig) {
		return ProblemControllerApiFp(this.configuration)
			.deleteProblem(id, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} id
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProblemControllerApi
	 */
	public getProblem(id: string, options?: RawAxiosRequestConfig) {
		return ProblemControllerApiFp(this.configuration)
			.getProblem(id, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} categoryId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProblemControllerApi
	 */
	public getProblemsByCategory(categoryId: string, options?: RawAxiosRequestConfig) {
		return ProblemControllerApiFp(this.configuration)
			.getProblemsByCategory(categoryId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProblemControllerApi
	 */
	public getProblemsCount(options?: RawAxiosRequestConfig) {
		return ProblemControllerApiFp(this.configuration)
			.getProblemsCount(options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} id
	 * @param {UpdateProblemRequest} updateProblemRequest
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProblemControllerApi
	 */
	public updateProblem(
		id: string,
		updateProblemRequest: UpdateProblemRequest,
		options?: RawAxiosRequestConfig
	) {
		return ProblemControllerApiFp(this.configuration)
			.updateProblem(id, updateProblemRequest, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * TestControllerApi - axios parameter creator
 * @export
 */
export const TestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		test: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
			const localVarPath = `/api/getUserId`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearerAuth required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions
			};
		}
	};
};

/**
 * TestControllerApi - functional programming interface
 * @export
 */
export const TestControllerApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = TestControllerApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async test(
			options?: RawAxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.test(options);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap['TestControllerApi.test']?.[localVarOperationServerIndex]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		}
	};
};

/**
 * TestControllerApi - factory interface
 * @export
 */
export const TestControllerApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = TestControllerApiFp(configuration);
	return {
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		test(options?: any): AxiosPromise<string> {
			return localVarFp.test(options).then((request) => request(axios, basePath));
		}
	};
};

/**
 * TestControllerApi - object-oriented interface
 * @export
 * @class TestControllerApi
 * @extends {BaseAPI}
 */
export class TestControllerApi extends BaseAPI {
	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TestControllerApi
	 */
	public test(options?: RawAxiosRequestConfig) {
		return TestControllerApiFp(this.configuration)
			.test(options)
			.then((request) => request(this.axios, this.basePath));
	}
}
